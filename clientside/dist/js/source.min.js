/* Константы кодов ошибок */
var ERROR_TYPE_DEFAULT = 1;
var ERROR_TYPE_ENGINE = 2;
var ERROR_TYPE_DATABASE = 3;
var ERROR_TYPE_LDAP = 4;

/* Константы типов данных */
var DATA_TYPE_INTEGER = 1;
var DATA_TYPE_STRING = 2;
var DATA_TYPE_FLOAT = 3;
var DATA_TYPE_BOOLEAN = 4;



/**
 * Класс поля модели данных
 * @param parameters {Object} - Параметры инициализации создаваемого объекта
 * @constructor
 */
function Field (parameters) {
    var isChanged = false;
    var beforeChange = "";

    this.source = "";           // Наименование поля-источника данных в БД
    this.value = undefined;     // Значение поля
    this.default_value = "";    // Значение поля по умолчанию
    this.backupable = false;    // Флаг, требуется ли резервировать значение поля
    this.displayable = true;    // Флаг, требуется ли отображать поле
    this.required = false;      // Флаг, является ли поле обязательным для заполнения
    this.title = "";
    this.isValid = false;
    this.raw = false;
    this.type = undefined;

    this._fromAnother_ = function (parameters) {
        if (parameters == undefined || parameters === null) {
            $errors.add(ERROR_TYPE_DEFAULT, "Field -> fromAnother: Не задан параметр - параметры инициализации");
            return false;
        } else {
            for (var param in parameters) {
                if (this.hasOwnProperty(param))
                    this[param] = parameters[param];
            }
        }
    };

    this._change_ = function (flag) {
        if (flag !== undefined && typeof flag === "boolean")
            isChanged = flag;
        return isChanged;
    };

    this._backup_ = function (value) {
        if (value !== undefined)
            beforeChange = value;
        else {
            switch (this.type) {
                case DATA_TYPE_STRING:
                    this.value = beforeChange.toString();
                    break;
                case DATA_TYPE_INTEGER:
                    this.value = parseInt(beforeChange);
                    break;
                case DATA_TYPE_FLOAT:
                    this.value =+ parseFloat(beforeChange).toFixed(6);
                    break;
                case DATA_TYPE_BOOLEAN:
                    this.value = new Boolean(beforeChange);
                    break;
                default:
                    this.value = beforeChange;
                    break;
            }
            this._change_(false);
        }
    };

    if (parameters !== undefined) {
        for (var param in parameters) {
            if (this.hasOwnProperty(param)) {
                this[param] = parameters[param];
            }
        }
        beforeChange = this.value;
    }
};

angular
    .module("homunculus", []);


angular
    .module("homunculus")
    .factory("$classes", ["$log", function ($log) {
        var items = {};

        /**
         * Добавляет класс в стек классов
         * @param className - Наименование класса
         * @param classDefinition - Определение класса
         * @returns {boolean}
         */
        var add = function (title, definition) {
            if (title !== undefined && definition !== undefined && typeof(definition) == "object") {
                items[title] = definition;
                //$log.info("Класс " + title + " добавлен в стек классов");
                //$log.log("total = ", items);
                return true;
            } else
                return false;
        };
        
        return {
            /**
             * Добавляет класс в стек классов
             * @param className - Наименование класса
             * @param classDefifnition - Определение класса
             * @returns {boolean}
             */
            add: function (className, classDefinition) {
                add(className, classDefinition);
            },

            /**
             * Возвращает все классы из стека
             * @returns {{}}
             */
            getAll: function () {
                return items;
            }
        };
    }]);

var homunculusInjector = angular.injector(['ng', 'homunculus']);
var $classesInjector = homunculusInjector.get('$classes');

angular
    .module("homunculus")
    .factory("$errors", ["$log", "$classes", "$factory", function ($log, $classes, $factory) {
        
        var items = [];
        var errors = [];
        var types = {
            ERROR_TYPE_DEFAULT: 1,
            ERROR_TYPE_ENGINE: 2,
            ERROR_TYPE_DATABASE: 3
        };

        return {
            /**
             * Добавляет ошибку в стек
             * @param errorType - Тип ошибки
             * @param errorMessage - Текст ошибки
             * @returns {*} - Error / false
             */
            add: function (errorType, errorMessage) {
                if (errorType !== undefined) {
                    if (!isNaN(errorType)) {
                        if (errorMessage !== undefined) {
                            var tempError = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                            tempError.type.value = errorType;
                            tempError.message.value = errorMessage;
                            tempError.timestamp.value = Math.floor(Date.now() / 1000);
                            items.push(tempError);
                            $log.error(moment.unix(tempError.timestamp.value).format("DD.MM.YYYY HH:mm") + ": " + tempError.message.value);
                            return tempError;
                        } else {
                            $log.error("$errors -> add: Не задан параметр - текст ошибки");
                            return false;
                        }
                    } else {
                        $log.error("$errors -> add: Неверно задан тип параметра - тип ошибки");
                        return false;
                    }
                } else {
                    $log.error("$errors -> add: Не задан параметр - тип ошибки");
                    return false;
                }
            },

            /**
             * Возвращает стек ошибок
             * @returns {Array}
             */
            getAll: function () {
                return items;
            },

            /**
             * Проверяет, является ли объект экземпляром ошибки
             * @param error - Объект для проверки
             * @returns {boolean}
             */
            isError: function (error) {
                if (error !== undefined) {
                    if (typeof error === "object" && error.type !== undefined && error.message !== undefined && error.timestamp !== undefined) {
                        this.add(error.type, error.message);
                        return true;
                    } else
                        return false;
                } else {
                    var tempError = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                    tempError.type.value = ERROR_TYPE_DEFAULT;
                    tempError.message.value = "$errors -> isError: Не задан параметр - объект для проверки";
                    tempError.timestamp.value = Math.floor(Date.now() / 1000);
                    items.push(tempError);
                    return false;
                }
            },

            init: function () {
                if (window.krypton !== undefined && window.krypton !== null) {
                    if (window.krypton.errors !== undefined) {
                        var length = window.krypton.errors.length;
                        for (var i = 0; i < length; i++) {
                            var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                            error._model_.fromAnother(window.krypton.errors[i]);
                            items.push(error);
                            $log.error(error.message.value);
                        }
                    }
                }
            },

            checkResponse: function (data) {
                if (data === undefined) {
                    this.add(ERROR_TYPE_DEFAULT, "$errors -> check: Не задан параметр - ответ сервера");
                    return false;
                }

                if (data.errors !== undefined && data.errors.length > 0) {
                    var length = data.errors.length;
                    for (var i = 0; i < length; i++) {
                        var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                        error.type.value = data.errors[i].type;
                        error.message.value = data.errors[i].message;
                        error.timestamp.value = data.errors[i].timestamp;
                        items.push(error);
                    }
                }
            },








            /**
             * Объект с типами ошибок
             */
            type: types,



            /**
             * Производит инициализацию из источника данных
             * @param source {array/object} - источник данных
             * @returns {boolean} - возвращает true в случае успешного завершения, false - в противном случае
             */
            init: function (source) {
                if (source === undefined) {
                    this.throw(types.ERROR_TYPE_DEFAULT, "$errors -> init: Не задан параметр - источник данных");
                    return false;
                }

                switch (typeof source) {
                    case "array":
                        var length = source.length;
                        for (var i = 0; i < length; i++) {
                            var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                            error._model_.fromJSON(source[i]);
                            errors.push(error);
                        }
                        break;
                    case "object":
                        var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                        error._model_.fromJSON(source);
                        errors.push(error);
                        break;
                }
                return true;
            },



            /**
             * Генерирует ошибку
             * @param type {number} - тип ошибки
             * @param message {string} - содержание ошибки
             * @returns {boolean} - возвращает true в случае успешного завершения, false - в противном случае
             */
            throw: function (type, message) {
                if (type === undefined) {
                    $log.error("$errors -> throw: Не задан параметр - тип ошибки");
                    return false;
                }

                var errorTypeFound = false;
                for (var i in types) {
                    if (types[i] === type)
                        errorTypeFound = true;
                }
                if (errorTypeFound === false) {
                    $log.error("$errors -> throw: Неверно задан тип ошибки");
                    return false;
                }

                if (message === undefined || message === "") {
                    $log.error("$errors -> throw: Не задан параметр - содержание ошибки");
                    return false;
                }

                var now = new moment();
                var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                error.timestamp = now.unix();
                error.type = type;
                error.message = message;
                errors.push(error);
                $log.error(now.format("DD.MM.YYYY HH:mm") + " " + message);
                return true;
            },



            /**
             * Производит проверку данных на наличие ошибок
             * @param data {object} - объект с данными, которые требуется проверить на наличие ошибок
             * @returns {boolean} - возвращает true в случае успешного завершения, false - в противном случае
             */
            check: function (data) {
                if (data === undefined) {
                    this.throw(ERROR_TYPE_DEFAULT, "$errors -> check: Не задан параметр - данные для проверки");
                    return false;
                }

                if (data.errors !== undefined && typeof data.errors === "array") {
                    if (data.errors.length > 0) {
                        for (var i = 0; i < data.errors; i++) {
                            var error = $factory({ classes: ["Error", "Model"], base_class: "Error" });
                            error._model_.fromJSON(data.errors[i]);
                            errors.push(error);
                            this.throw(error.type, error.message);
                        }
                    }
                    return true;
                }
            }
        }
    }]);

angular
    .module("homunculus")
    .factory("$factory", ["$log", "$classes", function ($log, $classes) {
        function FactoryObject (parameters) {

            var clone = function _clone(obj) {
                if (obj instanceof Array) {
                    var out = [];
                    for (var i = 0, len = obj.length; i < len; i++) {
                        var value = obj[i];
                        out[i] = (value !== null && typeof value === "object") ? _clone(value) : value;
                    }
                } else {
                    var out = new obj.constructor();
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            var value = obj[key];
                            out[key] = (value !== null && typeof value === "object") ? _clone(value) : value;
                        }
                    }
                }
                return out;
            };

            var _clone = function (it) {
                return this._clone({
                    it: it
                }).it;
            };


            var classes = $classesInjector.getAll();
            var addClass = function (className, destination) {
                if (className !== undefined && destination !== undefined) {
                    if (classes.hasOwnProperty(className)) {
                        destination.init_functions = [];
                        for (var prop in classes[className]) {
                            if (prop !== "__dependencies__") {
                                if (classes[className][prop].constructor !== Function) {
                                    destination[prop] = clone(classes[className][prop]);
                                    if (destination[prop]["__instance__"] !== undefined)
                                        destination[prop]["__instance__"] = destination;
                                    if (destination[prop]["_init_"] !== undefined && destination[prop]["_init_"].constructor === Function)
                                        destination.init_functions.push(destination[prop]["_init_"]);
                                    if (destination["_init_"] !== undefined && destination["_init_"].constructor === Function)
                                        destination.init_functions.push(destination["_init_"]);

                                } else {
                                    destination[prop] = classes[className][prop];
                                    if (prop === "_init_")
                                        destination.init_functions.push(destination[prop]);
                                }
                            }
                        }
                    }
                }
            };


            if (parameters !== undefined) {
                if (parameters.hasOwnProperty("classes")) {
                    if (parameters["classes"].constructor === Array) {
                        for (var parent in parameters["classes"]) {
                            var class_name = parameters["classes"][parent];
                            addClass(class_name, this);
                        }
                    }
                }
                if (parameters.hasOwnProperty("base_class")) {
                    if (classes.hasOwnProperty(parameters["base_class"])) {
                        this.__class__ = parameters["base_class"];
                    }
                }

                if (parameters.hasOwnProperty("init")) {
                    for (var x in parameters.init) {
                        if (this.hasOwnProperty(x))
                            if (this[x].constructor === Field)
                                this[x].value = parameters.init[x];
                            else
                                this[x] = parameters.init[x];
                    }
                }
            }

        };

        return function (parameters) {
            var obj = new FactoryObject(parameters);
            /*
            if (obj.init_functions.length > 0) {
                for (var i = 0; i < obj.init_functions.length; i++) {
                    obj.init_functions[i].call(obj);
                }
            }
            */
            //return new FactoryObject(parameters);
            return obj;
        };
    }]);

var injector = angular.injector(['ng', 'homunculus']);
var factory = injector.get('$factory');

angular
    .module("homunculus")
    .factory("$navigation", ["$log", "$rootScope", "$factory", "$errors", function ($log, $rootScope, $factory, $errors) {
        var menu = [];
        var breadcrumb = [];
        var currentMenuItem = undefined;

        var getById = function (id) {
            if (id === undefined && id === "") {
                $errors.add(ERROR_TYPE_DEFAULT, "$navigation -> GetById: Не задан парметр - идентификатор раздела");
                return false;
            }

            var length = menu.length;
            for (var i = 0; i < length; i++) {
                if (menu[i].id === id) {
                    return menu[i];
                }
            }
            return false;
        };

        $rootScope.$on("$routeChangeStart", function (event, next, current) {
            //$log.log("current = ", current);
            //$log.log("next = ", next);

            breadcrumb = [];
            var length = menu.length;
            for (var i = 0; i < length; i++) {
                var parent = getById(menu[i].parentId);
                if (menu[i].url === next.$$route.originalPath) {
                    breadcrumb.push(menu[i]);
                    for (var y = 0; y < length; y++) {
                        if (menu[y].parentId === menu[i].id)
                            menu[y].isParentActive = true;
                        else
                            menu[y].isParentActive = false;
                    }
                    if (menu[i].parentId !== "") {
                        var parentId = menu[i].parentId;
                        //$log.log("parentId = ", parentId);
                        while (parentId !== "") {
                            for (var x = 0; x < length; x++) {
                                if (menu[x].id === parentId) {
                                    breadcrumb.unshift(menu[x]);
                                    parentId = menu[x].parentId;
                                }
                            }
                        }

                    }

                    //var breadcrumbLength = breadcrumb.length;
                    //for (var z = 0; z < breadcrumbLength; z++) {
                    //    if (z === 0)
                    //        breadcrumb[z].isActive = true;
                    //    else
                    //        breadcrumb[z].isActive = false;
                    //}
                    menu[i].isActive = true;
                    currentMenuItem = menu[i];
                } else
                    menu[i].isActive = false;
            }

            //$log.log("breadcrumb = ", breadcrumb);
        });

        return {

            getAll: function () {
                return menu;
            },

            add: function (parameters) {
                if (parameters === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$navigation -> add: Не задан объект с параметрами");
                    return false;
                }

                if (parameters.id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$navigation -> add: Не задан параметр - идентификатор раздела");
                    return false;
                }

                if (parameters.url === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$navigation -> add: Не задан параметр - url раздела");
                    return false;
                }

                var item = $factory({ classes: ["MenuItem"], base_class: "MenuItem" });
                item.id = parameters.id;
                item.parentId = parameters.parentId !== undefined ? parameters.parentId : "";
                item.url = parameters.url;
                item.order = parameters.order !== undefined ? parameters.order : 0;
                item.icon = parameters.icon !== undefined ? parameters.icon : "";
                item.title = parameters.title !== undefined ? parameters.title : "";
                item.description = parameters.description !== undefined ? parameters.description : "";
                item.isVisible = parameters.isVisible !== undefined ? parameters.isVisible : true;

                menu.push(item);
                //$log.info("menus = ", menu);
            },

            select: function (menuId, callback) {
                if (menuId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$navigation -> select: Не задан параметр - идентификатор раздела");
                    return false;
                }

                var length = menu.length;
                var found = false;
                for (var i = 0; i < length; i++) {
                    if (menu[i].id === menuId) {
                        menu[i].isActive = true;
                        found = true;
                        currentMenuItem = menu[i];
                        if (callback !== undefined && typeof callback === "function")
                            callback(currentMenuItem);
                    } else
                        menu[i].isActive = false;
                    return found;
                }
            }

        }
    }]);
angular
    .module("homunculus")
    .factory("$session", ["$log", "$http", "$classes", "$factory", "$errors", function ($log, $http, $classes, $factory, $errors) {
        var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
        //$log.log("user = ", user);

        return {

            init: function (source) {
                if (source === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$session -> init: не задан парметр - источник данных");
                    return false;
                }

                if (source.user !== undefined && source.user !== null) {
                    user._model_.fromJSON(source.user);
                }
            },

            getCurrentUser: function () {
                return user;
            },

            login: function (login, password, callback) {
                if (login === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$authorization -> login: Не задан параметр - логин пользователя");
                    return false;
                }

                if (password === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$authorization -> login: Не задан параметр - пароль пользователя");
                    return false;
                }

                var params = {
                    action: "login",
                    data: {
                        login: login,
                        password: password
                    }
                };
                $http.post("/serverside/api.php", params)
                    .success(function (data) {
                        if (data !== undefined) {
                            if (data !== "false") {
                                var temp_user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                temp_user._model_.fromJSON(data);
                                user._model_.fromJSON(data);
                                if (callback !== undefined && typeof callback === "function")
                                    callback(user);
                                return true;
                            } else {
                                if (callback !== undefined && typeof callback === "function")
                                    callback(false);
                                return true;
                            }
                        }
                        return false;
                    });
            },


            logout: function (callback) {
                if (user.id.value === 0) {
                    $errors.add(ERROR_TYPE_ENGINE, "$session -> logout: Пользователь не авторизован");
                    return false;
                }

                var params = {
                    action: "logout",
                    data: {
                        userId: user.id.value
                    }
                };

                $http.post("/serverside/api.php", params)
                    .success(function () {
                        user.id.value = 0;
                        if (callback !== undefined && typeof callback === "function")
                            callback();
                        return true;
                    })
                    .error(function () {
                        return false;
                    });
            }
        }
    }]);

angular
    .module("homunculus")
    .factory("$settings", ["$log", "$http", "$errors", "$factory", function ($log, $http, $errors, $factory) {
        var settings = {};
        var isChanged = false;

        return api =  {

            /**
             *
             * @param source
             * @returns {boolean}
             */
            init: function (source) {
                if (source === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$settings -> init: Не задан параметр - источник данных");
                    return false;
                }

                var length = source.length;
                for (var i = 0; i < length; i++) {
                    var setting = $factory({ classes: ["Setting", "Model", "Backup", "States"], base_class: "Setting" });
                    setting._model_.fromJSON(source[i]);
                    setting._onConstruct();
                    setting._backup_.setup();
                    settings[setting.code.value] = setting;
                }

                console.log(settings);
            },


            /**
             *
             * @returns {Array}
             */
            getAll: function () {
                return settings;
            },


            /**
             *
             * @param code
             * @returns {*}
             */
            getByCode: function (code) {
                if (code === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$settings -> getByCode: Не задан параметр - код настройки");
                    return false;
                }

                for (var i in settings) {
                    if (settings[i].code.value === code)
                        return settings[i];
                }
                return false;
            },



            save: function (callback) {
                var params = {
                    action: "saveSettings",
                    data: {}
                };
                for (var setting in settings) {
                    params.data[setting] = settings[setting].value.value;
                }
                $http.post("/serverside/api.php", params).then(
                    function (response) {
                        if (response.data !== undefined && response.data === "true") {
                            if (callback !== undefined && typeof callback === "function")
                                callback();
                            return true;
                        }
                    },
                    function () {
                        $errors.throw($errors.type.ERROR_TYPE_ENGINE, "$settings -> save: Не удалось сохранить значение настроек");
                        return false;
                    }
                );
            },


            changed: function (flag) {
                if (flag !== undefined) {
                    isChanged = flag;
                }
                return isChanged;
            }
        }
    }]);
angular
    .module("homunculus")
    .factory("$users", ["$log", "$http", "$errors", "$classes", "$factory", function ($log, $http, $errors, $classes, $factory) {
        var users = [];
        var currentUser = undefined;
        var newUser = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
        var usersOnPage = 20;
        var currentPage = 1;

        newUser._backup_.setup();

        return {

            users: {


                init: function (source) {
                    if (source === undefined) {
                        $errors.add(ERROR_TYPE_DEFAULT, "$users -> init: Не задан параметр - источник данных");
                        return false;
                    }

                    var length = source.length;
                    for (var i = 0; i < length; i++) {
                        var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                        user._model_.fromJSON(source[i]);
                        user._backup_.setup();
                        users.push(user);
                    }
                    return true;
                },


                getAll: function () {
                    return users;
                },


                getCurrent: function () {
                    return currentUser;
                },

                getNew: function () {
                    return newUser;
                },

                getById: function (userId, callback) {
                    if (userId === undefined) {
                        $errors.add(ERROR_TYPE_DEFAULT, "$users -> users -> getById: Не задан параметр - идентификатор пользователя");
                        return false;
                    }

                    var length = users.length;
                    for (var i = 0; i < length; i++) {
                        if (users[i].id.value === userId) {
                            $log.info("getting user from cache");
                            currentUser = users[i];
                            return currentUser;
                        }
                    }

                    var params = {
                        action: "getUserById",
                        data: {
                            id: userId
                        }
                    };

                    return $http.post("/serverside/api.php", params).then(

                        function success(response) {
                            $log.info("promise success");
                            var user = $factory({classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser"});
                            user._model_.fromJSON(response.data);
                            user._backup_.setup();
                            currentUser = user;
                            if (callback !== undefined && typeof callback === "function")
                                callback(currentUser);
                            return currentUser;
                        },

                        function error() {
                            return false;
                        }
                    );
                },


                select: function (userId, callback) {
                    if (userId === undefined) {
                        $errors.add(ERROR_TYPE_DEFAULT, "$users -> users -> select: Не задан параметр - идентификатор пользователя");
                        return false;
                    }

                    var length = users.length;
                    for (var i = 0; i < length; i++) {
                        if (users[i].id.value === userId) {
                            if (callback !== undefined && typeof callback === "function")
                                callback(users[i]);
                            return users[i];
                        }
                    }
                    return false;
                },


                add: function (success, error) {
                    var params = {
                        action: "addUser",
                        data: {
                            divisionId: newUser.divisionId.value,
                            name: newUser.name.value,
                            fname: newUser.fname.value,
                            surname: newUser.surname.value,
                            email: newUser.email.value,
                            login: newUser.login.value,
                            password: newUser.password.value,
                            isAdministrator: newUser.isAdministrator.value === true ? 1 : 0,
                            allowEdit: newUser.allowEdit.value === true ? 1 : 0,
                            allowConfirm: newUser.allowConfirm.value === true ? 1 : 0
                        }
                    };
                    $http.post("/serverside/api.php", params)
                        .success(function (data) {
                            if (data !== undefined) {
                                var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                user._model_.fromJSON(data);
                                user._backup_.setup();
                                users.push(user);
                                newUser._backup_.restore();
                                if (success !== undefined && typeof success === "function")
                                    success(user);
                                return true;
                            } else
                                return false;
                        })
                        .error(function (data) {
                            if (error !== undefined && typeof error === "function")
                                error(data);
                            return false;
                        });
                },


                edit: function (callback) {
                    if (currentUser === undefined) {
                        $errors.add("$users -> users -> edit: Текущий пользователь не выбран");
                        return false;
                    }

                    var params = {
                        action: "editUser",
                        data: {
                            id: currentUser.id.value,
                            divisionId: currentUser.divisionId.value,
                            surname: currentUser.surname.value,
                            name: currentUser.name.value,
                            fname: currentUser.fname.value,
                            email: currentUser.email.value,
                            login: currentUser.login.value,
                            password: currentUser.password.value,
                            isAdministrator: currentUser.isAdministrator.value === true ? 1 : 0,
                            allowEdit: currentUser.allowEdit.value === true ? 1: 0,
                            allowConfirm: currentUser.allowConfirm.value === true ? 1 : 0,
                            isLDAPEnabled: currentUser.isLDAPEnabled.value === true ? 1 : 0
                        }
                    };

                    currentUser._states_.loading(true);
                    $http.post("/serverside/api.php", params)
                        .success(function (data) {
                            currentUser._states_.loading(false);
                            if (data !== undefined) {
                                var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                user._model_.fromJSON(data);
                                user._backup_.setup();
                                currentUser = user;
                                if (callback !== undefined && typeof callback === "function")
                                    callback(currentUser);
                                return true;
                            }
                            return false;
                        })
                        .error(function () {
                            currentUser._states_.loading(false);
                            return false;
                        });
                }

            },









            loadNextPage: function (callback) {
                var params = {
                    action: "loadUsers",
                    data: {
                        start: start
                    }
                };
            },





            edit: function (callback) {
                if (currentUser !== undefined) {
                    var params = {
                        action: "editUser", data: {
                            id: currentUser.id.value,
                            divisionId: currentUser.divisionId.value,
                            name: currentUser.name.value,
                            fname: currentUser.fname.value,
                            surname: currentUser.surname.value,
                            email: currentUser.email.value,
                            isAdministrator: currentUser.isAdministrator.value
                        }
                    };
                    $http.post("/serverside/api.php", params)
                        .success(function (data) {
                            if (data !== undefined) {
                                currentUser._backup_.setup();
                                currentUser._states_.changed(false);

                                if (callback !== undefined && typeof callback === "function")
                                    callback(currentUser);

                                return true;
                            }
                        });
                }
                return false;
            }
        }
    }]);
angular
    .module("homunculus")
    .directive("uploader", ["$log", "$http", "$errors", function ($log, $http, $errors) {
        return {
            restrict: "A",
            scope: {
                //uploaderUrl: "=",
                uploaderData: "=",
                uploaderOnCompleteUpload: "=",
                uploaderOnBeforeUpload: "="
            },
            link: function (scope, element, attrs) {
                var url = "";
                var fd = new FormData();

                if (attrs.uploaderUrl === undefined || attrs.uploaderUrl === "") {
                    $errors.add(ERROR_TYPE_DEFAULT, "uploader -> Не задан атрибут - url");
                    return false;
                }

                attrs.$observe("uploaderUrl", function (val) {
                    url = val;
                    $log.log("interpolated url = ", url);

                });

                /**
                 * Отслеживаем выбор файла для загрузки
                 */
                element.bind("change", function () {
                    //var fd = new FormData();
                    angular.forEach(element[0].files, function (file) {
                        $log.log(file);
                        fd.append("file", file);
                    });

                    /* Если задан коллбэк onBeforeUpload - выполняем его */
                    $log.log(scope.uploaderOnBeforeUpload);
                    if (scope.uploaderOnBeforeUpload !== undefined && typeof scope.uploaderOnBeforeUpload === "function") {
                        scope.$apply(scope.uploaderOnBeforeUpload);
                    }

                    /* Если заданы данные для отправки на сервер - добавляем их в данные формы для отправки */
                    if (scope.uploaderData !== undefined) {
                        $log.info(scope.uploaderData);
                        for (var param in scope.uploaderData) {
                            fd.append(param, scope.uploaderData[param]);
                        }
                    }

                    scope.upload();
                });

                /**
                 * Отправляет данные на сервер
                 */
                scope.upload = function () {

                    $log.info("upload, link = ", url);
                    if (fd.has("file")) {
                        element.prop("disabled", "disabled");
                        $http.post(url, fd,
                            {
                                transformRequest: angular.identity,
                                headers: {
                                    "Content-Type": undefined
                                }
                            }
                        ).success(function (data) {
                            $log.log(data);
                            element.prop("disabled", "");
                            if (scope.uploaderOnCompleteUpload !== undefined && typeof scope.uploaderOnCompleteUpload === "function")
                                scope.uploaderOnCompleteUpload(data);
                            fd.delete("file");
                            fd = new FormData();
                        });
                    }
                };

            }
        }
    }]);
angular
    .module("homunculus.ui", ["homunculus"]);

angular
    .module("homunculus.ui")
    .factory("$dateTimePicker", ["$log", "$window", "$document", "$http", "$compile", "$rootScope", "$errors", "$factory", function ($log, $window, $document, $http, $compile, $rootScope, $errors, $factory) {
        var instances = [];
        var template = "";
        var isTemplateLoading = false;

        return {

            push: function (scope) {
                if (scope !== undefined) {
                    var instance = $factory({ classes: ["DateTimePicker"], base_class: "DateTimePicker" });
                    instance.id = scope.settings.id;
                    instance.isModal = scope.settings.isModal;
                    instance.isOpened = scope.settings.isOpened;
                    instance.element = scope.settings.element;
                    instance.scope = scope;
                    instance.minDate = scope.settings.minDate;
                    instance.maxDate = scope.settings.maxDate;
                    instances.push(instance);
                    //$log.log(instances);
                    return instance;
                } else
                    return $errors.add(ERROR_TYPE_DEFAULT, "krypton.ui -> dateTimePicker directive: Не задан параметр - объект с настройками директивы");
            },


            show: function (elementId) {
                //$log.log("instances before = ", instances);
                if (elementId !== undefined) {
                    var length = instances.length;
                    for (var i = 0; i < length; i++) {
                        if (instances[i].element.getAttribute("id") === elementId)
                            $log.log("Element with id = " + elementId + " found!");
                    }
                } else
                    return $errors.add(ERROR_TYPE_DEFAULT, "krypton.ui -> dateTimePicker directive : Не задан параметр - идентификатор HTML_элемента");
            },







            /**
             * Добавляет новый элемент в стек
             * @param parameters - Набор параметров инициализации
             * @returns {*}
             */
            add: function (parameters) {
                if (parameters !== undefined) {
                    if (typeof parameters === "object") {
                        if (parameters.element !== undefined) {

                            var element = document.getElementById(parameters.element);
                            $log.log("element = ", element);
                            if (element !== undefined && element !== null) {
                                var picker = $factory({classes: ["DateTimePicker"], base_class: "DateTimePicker"});
                                picker.id = "dateTimePicker" + instances.length;
                                picker.element = element;

                                //var instance = this.exists(angular.element(picker.element).prop("id"));

                                //if (element.classList.contains("ng-isolate-scope") === true)
                                element.setAttribute("ui-date-time-picker", "");
                                ///element.setAttribute("ui-date-time-picker-opened", false);
                                //element.setAttribute("ng-if", "isOpened === true");

                                for (var param in parameters) {
                                    if (picker.hasOwnProperty(param)) {
                                        switch (param) {
                                            case "modelValue":
                                                picker.modelValue = parameters[param];
                                                //element.setAttribute("date-time-picker-model-value", dateTimePicker.modelValue);
                                                break;
                                            case "isModal":
                                                if (typeof parameters[param] === "boolean") {
                                                    picker.isModal = parameters[param];
                                                    //if (picker.isModal === true)
                                                    //    element.setAttribute("date-time-picker-modal", picker.isModal);
                                                } else
                                                    return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> add: Неверно задан тип параметра - модальный режим");
                                                break;
                                            case "title":
                                                picker.title = parameters[param] !== undefined && parameters[param] !== "" ? parameters[param] : "";
                                                //if (picker.title !== "")
                                                //    element.setAttribute("date-time-picker-title", picker.title);
                                                break;
                                        }
                                    }
                                }


                                instances.push(picker);
                                $log.log(instances);
                                //element.setAttribute("ui-date-time-picker", "");
                                $log.info("dtp = ", picker);
                                $compile(picker.element)($rootScope.$new());

                                return picker;
                            } else
                                return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> add: Элемент с идентификатором '" + parameters[param] + "' не найден");
                        } else
                            return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> add: Не задан целевой элемент");
                    } else
                        return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> add: Неверно задан тип параметра инициализации");
                } else
                    return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> add: Не заданы параметры инициализации");
            },



            open: function (elementId) {
                if (elementId !== undefined) {
                    var length = instances.length;
                    $log.log("instances defore", instances);
                    for (var i = 0; i < length; i++) {
                        var instanceFound = false;
                        if (angular.element(instances[i].element).prop("id") === elementId) {
                            instanceFound = true;
                            $log.log("element with id = " + elementId + " found");
                            $log.log(instances[i]);
                            instances[i].scope.open();
                        }
                        if (instanceFound === false)
                            $log.log("Element " + elementId + " not found");
                    }
                } else
                    return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> open: Не задан параметр - идентификатор элемента");
            },


            /**
             * Проверяет на наличие экземпляра по идентификатору элемента
             * @param elementId - Идкнтификатор элемента
             * @returns {*}
             */
            exists: function (elementId) {
                if (elementId !== undefined) {
                    $log.log("elementId = ", elementId.toString());
                    var length = instances.length;
                    for (var i = 0; i < length; i++) {
                        $log.log("instance element = ", instances[i].element.getAttribute("id"));
                        if (instances[i].element.getAttribute("id").toString() === elementId) {
                            $log.log("founded instance = ", instances[i]);
                            return instances[i];
                        }
                    }
                    return false;
                } else
                    return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> exists: Не задан параметр - идентификатор элкмкнта");
            },


            getTemplate: function () {
                return template;
            },


            setTemplate: function (tpl) {
                if (tpl !== undefined)
                    template = tpl;
                else
                    return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> setTemplate: Не задан параметр - содержимое шаблона");
            },

            loading: function (flag) {
                if (flag !== undefined) {
                    if (typeof flag === "boolean") {
                        isTemplateLoading = flag;
                        return isTemplateLoading;
                    } else
                        return $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> loading: Неверно задан тип параметр - флаг процесса загрузки шаблона");
                } else
                    return isTemplateLoading;
            },








            getAll: function () {
                return instances;
            },

            getById: function (id) {
                if (id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$dateTimePicker -> getById: Не задан параметр - идентификатор календаря");
                    return false;
                }

                var length = instances.length;
                for (var i = 0; i < length; i++) {
                    if (instances[i].id === id)
                        return instances[i];
                }
                return false;
            }


        }
    }]);

angular
    .module("homunculus.ui")
    .factory("$modals", ["$log", "$window", "$compile", "$errors", function ($log, $window, $compile, $errors) {
        var modals = [];

        var redraw = function (elm) {
            if (elm !== undefined) {
                var left = ($window.innerWidth / 2) - angular.element(elm).prop("clientWidth") / 2 + "px";
                var top = ($window.innerHeight / 2) - ((angular.element(elm).prop("clientHeight")) / 2) + "px";

                angular.element(elm).css("left", left);
                angular.element(elm).css("top", top);
            }
        };

        return {

            /**
             * Возвращает массив со всеми модальными окнами
             * @returns {Array}
             */
            getAll: function () {
                return modals;
            },

            /**
             * Возвращает scope модального окна с заданным идентификатором
             * @param id {string} - идентификатор модального окна
             * @returns {scope}
             */
            getById: function (id) {
                if (id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$modals -> getById: Не задан параметр - идентификатор модального окна");
                    return false;
                }

                var length = modals.length;
                for (var i = 0; i < length; i++) {
                    if (modals[i].id === id)
                        return modals[i];
                }

                return false;
            },

            /**
             * Регистирует модальное окно
             * @param scope {scope} - scope добавляемого модального окна
             * @returns {boolean}
             */
            register: function (modal) {
                if (modal === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$modals -> register: Не задан парметр - объект модального окна");
                    return false;
                }

                modals.push(modal);
                //$log.log("modals = ", items);

                return true;
            },

            /**
             * Открывает модальное окно с заданным идентификатором
             * @param id {string} - идентификатор модального окна
             * @returns {boolean}
             */
            open: function (id) {
                if (id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$modals -> open: Не задан параметр - идентификатор модального окна");
                    return false;
                }

                var length = modals.length;
                var found = false;
                for (var i = 0; i < length; i++) {
                    if (modals[i].id === id) {
                        found = true;
                        currentModal = modals[i];
                        var modal = document.getElementsByClassName("krypton-ui-modal")[0];
                        var header = document.getElementById("krypton-ui-modal-caption");
                        var content = document.getElementById("krypton-ui-modal-content");
                        var footer = document.getElementById("krypton-ui-modal-footer");
                        header.innerHTML = modals[i].caption;
                        content.innerHTML = modals[i].content;
                        if (modals[i].footer.content !== undefined) {
                            footer.innerHTML = modals[i].footer.content;
                            angular.element(footer).css("display", "block");

                            if (modals[i].footer.height !== 0) {
                                angular.element(footer).css("height", modals[i].footer.height + "px");
                                //angular.element(footer).css("max-height", modals[i].footer.height + "px");
                                //angular.element(content).css("bottom", modals[i].footer.height + "px");
                                //angular.element(content).css
                            }
                        } else {
                            angular.element(footer).css("display", "none");
                        }
                        $compile(modal)(modals[i].scope);
                        angular.element(modal).css("display", "block");

                        var fog = document.getElementsByClassName("krypton-ui-fog");
                        document.body.style.overflow = "hidden";
                        fog[0].classList.add("visible");
                        redraw(modal);

                        if (modals[i].width !== 0)
                            angular.element(modal).css("width", modals[i].width + "px");
                        if (modals[i].height !== 0) {
                            angular.element(modal).css("height", modals[i].height + "px");
                            angular.element(content).css("height", modals[i].height - 35 - modals[i].footer.height + "px");
                            //angular.element(content).css("height", items[i].height + "px");
                        } else {
                            angular.element(modal).css("height", "auto");
                            if (modals[i].footer.height !== 0)
                                angular.element(content).css("height", "auto");
                            else
                                angular.element(content).css("height", "100%");
                        }


                        modal.addEventListener("DOMSubtreeModified", function () {
                            redraw(modal);
                        }, false);

                        angular.element($window).bind("resize", function () {
                            redraw(modal);
                        });
                    }
                }

                if (found === false) {
                    $errors.add(ERROR_TYPE_ENGINE, "$modals -> open: Модальное окно с идентификатором '" + id + "' не найдено");
                    return false;
                } else
                    return true;
            },

            /**
             * Закрывает модальное окно с заданным идентификатором
             * @returns {boolean}
             */
            close: function () {
                if (currentModal !== undefined) {
                    var modal = document.getElementsByClassName("krypton-ui-modal")[0];
                    if (currentModal.onClose !== undefined)
                        currentModal.onClose();
                    var fog = document.getElementsByClassName("krypton-ui-fog");
                    document.body.style.overflow = "hidden";
                    fog[0].classList.remove("visible");
                    angular.element(modal).css("display", "none");
                    currentModal = undefined;
                    return true;
                }

                return false;
            }
        }
    }]);

angular
    .module("homunculus.ui")
    .factory("$tabs", ["$log", "$errors", function ($log, $errors) {
        var tabs = [];

        return {

            register: function (tab) {
                if (tab === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$tabs -> register: Не задан параметр - параметры регистрируемого компонента");
                    return false;
                }

                tabs.push(tab);
                $log.log("tabs", tabs);
                return true;
            },

            getById: function (id) {
                if (id === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$tabs -> getById: Не задан параметр - идентификатор компонента");
                    return false;
                }

                var length = tabs.length;
                for (var i = 0; i < length; i++) {
                    if (tabs[i].id === id)
                        return tabs[i];
                }
                return false;
            },

            select: function (tabsId, tabId) {
                if (tabsId === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$tabs -> select: Не задан параметр - идентификатор компонента");
                    return false;
                }

                if (tabId === undefined) {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$tabs -> select: Не задан параметр - идентификатор вкладки");
                    return false;
                }
            }

        }
    }]);
angular
    .module("homunculus.ui")
    .factory("$tree", ["$log", "$classes", "$factory", "$errors", function ($log, $classes, $factory, $errors) {
        var trees = [];
        
        return {



            register: function (parameters) {
                //$log.log("parameters = ", parameters);
                if (parameters === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> register: Не задан параметр - объект с настройками дерева");
                    return false;
                }

                if (parameters.id === undefined || parameters.id === "") {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> register: Не задан параметр дерева - идентификатор дерева");
                    return false;
                }

                if (parameters.rootKey === undefined || parameters.rootKey === "") {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> register: Не задан параметр дерева - значение ключа корневого элемента дерева");
                    return false;
                }

                var tree = $factory({ classes: ["TreeStructure"], base_class: "TreeStructure" });
                tree.id = parameters.id;
                tree.rootKey = parameters.rootKey;
                tree.expandOnSelect = parameters.expandOnSelect !== undefined ? true : false;
                tree.collapseOnDeselect = parameters.collapseOnDeselect !== undefined ? true: false;
                tree.onSelect = parameters.onSelect !== undefined && typeof parameters.onSelect === "function" ? parameters.onSelect : undefined;
                tree.showNotifications = parameters.showNotifications !== undefined ? parameters.showNotifications : true;
                trees.push(tree);

                //$log.log("structures = ", trees);

                return tree;
            },



            /**
             * Осуществляет поиск дерева по идентификатору
             * @param treeId {string} - идентификатор дерева
             * @returns {TreeStructure / boolean}
             */
            getById: function (treeId) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> getById: Не задан параметр - идентификатор дерева");
                    return false;
                }

                var length = trees.length;
                for (var i = 0; i < length; i++) {
                    if (trees[i].id === treeId)
                        return trees[i];
                }

                return false;
            },



            /**
             * Осуществляет поиск элемента дерева по значению ключа
             * @param treeId {string} идентификатор дерева
             * @param key {*} - значение ключа элемента
             * @returns {TreeItem / boolean}
             */
            getItemByKey: function (treeId, key) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> getItemByKey: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> getItemByKey: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> getItemByKey: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                return item !== undefined ? item : false;
            },



            /**
             *
             * @param treeId
             * @param key
             * @param parentKey
             * @param display
             * @param order
             * @param data
             * @returns {*}
             */
            addItem: function (parameters) {
                if (parameters === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$tree -> addItem: Не задан объект с параметрами");
                    return false;
                }

                if (parameters.treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (parameters.key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Не задан параметр - значение ключа элемента");
                    return false;
                }

                if (parameters.parentKey === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Не задан параметр - значение родительского ключа элемента");
                    return false;
                }

                if (parameters.display === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Не задан параметр - отображаемое значение элемента");
                    return false;
                }

                if (parameters.order !== undefined && parameters.order === "") {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Не задан параметр - порядковый номер отображения элемента");
                    return false;
                }

                var tree = this.getById(parameters.treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: Дерево с идентификатором '" + parameters.treeId + "' не найдено");
                    return false;
                }

                var item = $factory({ classes: ["TreeItem"], base_class: "TreeItem" });
                item.key = parameters.key;
                item.parentKey = parameters.parentKey;
                item.display = parameters.display;
                item.order = parameters.order;
                item.data = parameters.data !== undefined ? parameters.data : {};

                if (item.parentKey === tree.rootKey) {
                    tree.initial[item.key] = item;
                    tree.onAddItem(item);
                    tree.stack[item.key] = item;
                } else {
                    var parent = tree.stack[item.parentKey];
                    if (parent === undefined) {
                        $errors.add(ERROR_TYPE_DEFAULT, "$structure -> addItem: родительский элемент с ключом '" + parameters.parentKey + "' не найден");
                        return false;
                    }
                    tree.stack[item.key] = item;
                    parent.children[item.key] = item;
                    parent.childrenCount++;
                    tree.onAddItem(item);
                    parent.onAddChildren(item);
                }


                return item;
            },



            expandItem: function (treeId, key) {
                //$log.log("expand item called");

                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandItem: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandItem: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandItem: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$structure -> expandItem: Элемент с ключом " + key + " не найден");
                    return false;
                }

                if (item.childrenCount > 0)
                    item.isExpanded = true;
                //$log.log(item);
                return true;
            },



            expandToRoot: function (treeId, key) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandToRoot: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandToRoot: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> expandToRoot: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$structure -> expandToRoot: Элемент с ключом " + key + " не найден");
                    return false;
                }

                var parent = tree.stack[item.parentKey];
                while (parent) {
                    parent.isExpanded = true;
                    parent = tree.stack[parent.parentKey];
                }
            },



            collapseItem: function (treeId, key) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> collapseItem: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> collapseItem: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> collapseItem: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$structure -> collapseItem: Элемент с ключом " + key + " не найден");
                    return false;
                }

                item.isExpanded = false;
                return true;
            },



            selectItem: function (treeId, key) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> selectItem: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> selectItem: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> selectItem: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$structure -> selectItem: Элемент с ключом " + key + " не найден");
                    return false;
                }



                for (var index in tree.stack) {
                    var itm = tree.stack[index];
                    if (itm.key === key) {
                        if (itm.isSelected === true) {
                            itm.isSelected = false;
                            tree.selectedItem = false;
                            if (tree.collapseOnDeselect === true)
                                itm.isExpanded = false;
                        } else {
                            itm.isSelected = true;
                            tree.selectedItem = itm;
                            if (tree.expandOnSelect === true) {
                                if (itm.childrenCount > 0)
                                    itm.isExpanded = true;
                            }
                        }
                        tree.onSelect(itm);
                        //$log.log("selected item = ", itm);
                    } else
                        itm.isSelected = false;
                }
                return true;
            },
            
            
            isChildrenOf: function (treeId, key, parentKey) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$tree -> isChildrenOf: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$tree -> isChildrenOf: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$tree -> isChildrenOf: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$tree -> isChildrenOf: Элемент с ключом " + key + " не найден");
                    return false;
                }

                var parent = tree.stack[parentKey];
                if (parent === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$tree -> isChildrenOf: родительсктй элемент с ключом " + parentKey + " не найден");
                    return false;
                }

                var parent = item;
                while (parent) {
                    parent = tree.stack[parent.parentKey];
                }
            },
            


            calcViolations: function (treeId, key) {
                if (treeId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> calc: Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (key === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> calc: Не задан параметр - значение ключа элемента");
                    return false;
                }

                var tree = this.getById(treeId);
                if (!tree) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$structure -> calc: Дерево с идентификатором '" + treeId + "' не найдено");
                    return false;
                }

                var item = tree.stack[key];
                if (item === undefined) {
                    $errors.add(ERROR_TYPE_ENGINE, "$structure -> calc: Элемент с ключом " + key + " не найден");
                    return false;
                }

                var result = 0;
                for (var index in item.children) {
                    var child = item.children[index];
                    result += child.data.violationsAdded;
                }

                return result;
            }



        }
    }]);

angular
    .module("homunculus.ui")
    .directive("uiDateTimePicker", ["$log", "$compile", "$window", "$document", "$errors", "$dateTimePicker", function ($log, $compile, $window, $document, $errors, $dateTimePicker) {
        return {
            restrict: "A",
            require: "ngModel",
            priority: 10,
            scope: {
                ngModel: "=",
                dateTimePickerModal: "=",
                dateTimePickerEnableTime: "=",
                dateTimePickerEnableMinutes: "=",
                dateTimePickerThroughNavigation: "=",
                dateTimePickerNoValue: "@",
                dateTimePickerOnSelect: "=",
                dateTimePickerMinDate: "=",
                dateTimePickerMaxDate: "=",
                dateTimePickerFormat: "@"
            },
            link: function (scope, element, attrs, controller) {

                var template =
                    "<div class='toolbar'>" +
                    "<div class='control'><button class='width-100 blue' ng-class='{ \"very-big\": settings.isModal === true }' ng-click='prev()'>&larr;</button></div>" +
                    "<div class='content'>" +
                    "<select class='width-60 no-border' ng-if='isInTimeSelectMode === false' ng-model='month' ng-options='month[0] as month[1] for month in months'></select>" +
                    "<select class='width-40 no-border' ng-if='isInTimeSelectMode === false' ng-model='year' ng-options='year as year for year in years'></select>" +
                    "<span class='selected-date width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === false && settings.isModal === false'>{{ value.format('DD.MM.YYYY, HH ч.') }}</span>" +
                    "<span class='selected-date width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === false && settings.isModal === true'>{{ value.format('DD MMM YYYY, HH ч.') }}</span>" +
                    "<span class='selected-date width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === true && settings.isModal === false'>{{ value.format('DD.MM.YYYY, HH:mm') }}</span>" +
                    "<span class='selected-date width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === true && settings.isModal === true'>{{ value.format('DD MMM YYYY, HH:mm') }}</span>" +
                    "</div>" +
                    "<div class='control'><button class='width-100 blue' ng-class='{ \"very-big\": settings.isModal === true }' ng-click='next()'>&rarr;</button></div>" +
                    "</div>" +
                    "<div class='weekdays'>" +
                    "<div class='day width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === false'>часы</div>" +
                    "<div class='day width-100' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === true'>минуты</div>" +
                    "<div class='day' ng-if='isInTimeSelectMode === false' ng-repeat='weekday in weekdays track by $index'>" +
                    "<span ng-if='settings.isModal === true'>{{ weekday[1] }}</span><span ng-if='settings.isModal === false'>{{ weekday[0] }}</span>" +
                    "</div>" +
                    "</div>" +
                    "<div class='days-container' style='height:{{ height + \"px\" }}; max-height:{{ height }};'>" +
                    "<div class='day' ng-if='isInTimeSelectMode === false' ng-class='{\"sunday\": ($index + 1) % 7 === 0, \"not-this-month\": day.month() !== month, \"current\": day.date() === now.date() && day.month() === value.month(), \"disabled\": day.unix() < settings.minDate || day.unix() > settings.maxDate }' ng-repeat='day in days track by $index' ng-click='select(day.unix())'>{{ day.date() }}</div>" +
                    "<div style='line-height: {{ height / 4 + \"px\" }};' class='hour' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === false' ng-class='{\"current\": value.hours() === $index}' ng-repeat='hour in hours track by $index' ng-click='select($index)'>{{ hour }}</div>" +
                    "<div style='line-height: {{ height / 3 + \"px\" }};' class='minute' ng-if='isInTimeSelectMode === true && isInMinutesSelectMode === true' ng-class='{\"current\": value.minutes() === ($index * 5)}' ng-repeat='minute in minutes track by $index' ng-click='select(minute)'>{{ minute }}</div>" +
                    "</div>";


                if (attrs.dateTimePickerId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "date-time-picker: Не задан идентификатор календаря");
                    return false;
                }


                //controller.$render = function () {
                //    $log.log("dateTimePicker render called");
                    //if (scope.settings.isTimeEnabled === true)
                    //    element.val(moment.unix(controller).format("DD.MM.YYYY HH:mm"));
                    //else
                    //    element.val(moment.unix(controller).format("DD.MM.YYYY"));
                //};


                /*
                scope.$watch("ngModel", function (val) {
                    $log.log("newVal = ", val);
                    //controller.$render();
                    if (scope.settings.isTimeEnabled === true)
                        element.val(moment.unix(val).format("DD.MM.YYYY HH:mm"));
                    else
                        element.val(moment.unix(val).format("DD.MM.YYYY"));
                });
                */




                var height = scope.height = 0;
                var calendarHeight = scope.calendarHeight = 0;
                var ctrl = scope.ctrl = controller;
                var days = scope.days = [];
                var weekdays = scope.weekdays = [
                    ["Пн", "Понедельник"], ["Вт", "Вторник"],
                    ["Ср", "Среда"], ["Чт", "Четверг"] ,
                    ["Пт", "Пятница"], ["Сб", "Суббота"],
                    ["Вс", "Воскресение"]
                ];
                var months = scope.months =  [
                    [0, "Январь"] ,[1, "Февраль"], [2, "Март"],
                    [3, "Апрель"], [4, "Май"], [5, "Июнь"],
                    [6, "Июль"], [7, "Август"], [8, "Сентябрь"],
                    [9, "Октябрь"], [10, "Ноябрь"], [11, "Декабрь"]
                ];
                var hours = scope.hours = [
                    "00", "01", "02", "03",
                    "04", "05", "06", "07",
                    "08", "09", "10", "11",
                    "12", "13", "14", "15",
                    "16", "17", "18", "19",
                    "20", "21", "22", "23"
                ];
                var minutes = scope.minutes = [
                    "00", "05", "10", "15",
                    "20", "25", "30", "35",
                    "40", "45", "50", "55"
                ];

                var now = scope.now = moment(new Date());
                var date = scope.date = moment(now);
                var value = scope.value = moment(now);
                var day = scope.day = value.date();
                var month = scope.month = date.month();
                var year = scope.year = moment(value).year();
                //var hour = scope.hour = moment(value).hours();
                //var minute = scope.minute = moment(value).minutes();
                var years = scope.years = [];

                for (var i = moment(value).year() - 5; i < moment(value).year() + 5; i++) {
                    years.push(i);
                    if (i === moment(value).year())
                        selectedYear = i;
                }

                var isInTimeSelectMode = scope.isInTimeSelectMode = false;
                var isInMinutesSelectMode = scope.isInMinutesSelectMode = false;

                var settings = scope.settings = {
                    id: attrs.dateTimePickerId,
                    // Модальный режим отображения виджета
                    isModal: scope.dateTimePickerModal !== null && scope.dateTimePickerModal !== undefined ? true : false,
                    isOpened: false,
                    // Режим выбора времени
                    isTimeEnabled: scope.dateTimePickerEnableTime !== null && scope.dateTimePickerEnableTime !== undefined ? true : false,
                    // Сквозная навигация по часам и минутам
                    isTroughNavigationEnabled: scope.dateTimePickerThroughNavigation !== null && scope.dateTimePickerThroughNavigation !== undefined ? true : false,
                    title: "",
                    noValue: scope.dateTimePickerNoValue !== null && scope.dateTimePickerNoValue !== undefined && scope.dateTimePickerNoValue !== "" ? scope.dateTimePickerNoValue : undefined,
                    element: element,
                    onSelect: scope.dateTimePickerOnSelect !== null && scope.dateTimePickerOnSelect !== undefined ? scope.dateTimePickerOnSelect : undefined,
                    minDate: scope.dateTimePickerMinDate !== null && scope.dateTimePickerMinDate !== undefined ? scope.dateTimePickerMinDate : 0,
                    maxDate: scope.dateTimePickerMaxDate !== null && scope.dateTimePickerMaxDate !== undefined ? scope.dateTimePickerMaxDate : Number.POSITIVE_INFINITY,
                    format: scope.dateTimePickerFormat !== null && scope.dateTimePickerFormat !== undefined && scope.dateTimePickerFormat !== "" ? scope.dateTimePickerFormat : "DD MMM YYYY"
                };


                //$log.info("settings = ", scope.settings);


                var recalculate = function (monthNumber) {
                    if (monthNumber !== undefined) {
                        var daysInMonth = moment(monthNumber + "-" + scope.year, "MM-YYYY").daysInMonth();
                        var weekDayOfFirstDay = moment("01." + monthNumber + "." + scope.year, "DD.MM.YYYY").weekday();
                        var weekDayOfLastDay = moment(daysInMonth + "." + monthNumber + "." + scope.year, "DD.MM.YYYY").weekday();
                        var lastDayInSelectedMonth = "";
                        //$log.log("in month number " + monthNumber + " - " + daysInMonth + " days");
                        //$log.log("first day in month = ", weekDayOfFirstDay);
                        //$log.log("last day in month = ", weekDayOfLastDay);

                        days.splice(0, days.length);
                        if (weekDayOfFirstDay > 0) {
                            var start = moment("01." + monthNumber + "." + scope.year + " 00:00", "DD.MM.YYYY HH:mm").subtract(weekDayOfFirstDay, "days");
                            //$log.log("first day in calendar = ", moment(start).format("DD.MM.YYYY"));
                            for (var x = 0; x < weekDayOfFirstDay; x++) {
                                var day = moment(start).add(x, "days");
                                days.push(day);
                            }
                        }
                        for (var i = 1; i <= daysInMonth; i++) {
                            var day = moment(i + "." + monthNumber + "." + scope.year + " 00:00", "DD.MM.YYYY HH:mm");
                            days.push(day);
                            if (moment(day).date() === daysInMonth) {
                                lastDayInSelectedMonth = day;
                                //$log.log("last day = ", moment(lastDayInSelectedMonth).format("DD.MM.YYYY"));
                            }

                            //$log.log("last day in month2 = ", weekDayOfLastDay);

                        }
                        if (weekDayOfLastDay < 6) {
                            //$log.log("last day in calendar = ", moment(start).format("DD.MM.YYYY"));
                            var start = moment(lastDayInSelectedMonth).add(1, "days");
                            for (var i = 1; i <= (6 - weekDayOfLastDay); i++) {
                                var day = moment(lastDayInSelectedMonth).add(i, "days");
                                days.push(day);
                            }
                        }
                    } else
                        return $errors.add(
                            ERROR_TYPE_DEFAULT,
                            "krypton.ui -> dateTimePicker directive: Не задан параметр - порядковый номер месяца"
                        );
                };


                var redraw = function (elm) {
                    if (elm !== undefined) {
                        var elementWidth = angular.element(element).prop("clientWidth");
                        var elementHeight = angular.element(element).prop("clientHeight");
                        var elementLeft = angular.element(element).prop("offsetLeft");
                        var elementTop = angular.element(element).prop("offsetTop");
                        var containerWidth = angular.element(elm).prop("clientWidth");
                        var containerHeight = angular.element(elm).prop("clientHeight");
                        var elementScrollTop = 0;
                        var elementScrollLeft = 0;
                        var windowWidth = $window.innerWidth;
                        var windowHeight = $window.innerHeight;
                        var left = 0;
                        var top = 0;

                        var parent = element[0].offsetParent;
                        //$log.log("parent = ", parent);
                        while (parent) {
                            //elementTop = elementTop + parent.offsetTop;
                            //elementLeft = elementLeft + parent.offsetLeft;
                            elementScrollLeft = elementScrollLeft + parent.scrollLeft;
                            elementScrollTop = elementScrollTop + parent.scrollTop;
                            parent = parent.offsetParent;
                        }
                        //$log.log("containerTop = ", elementScrollTop);
                        //$log.log("containerLeft = ", elementScrollLeft);


                        //return {top: Math.round(top), left: Math.round(left), offsetX: Math.round(offsetX), offsetY: Math.round(offsetY)};
                        //};

                        //$log.log(angular.element($document).parent());

                        if (scope.settings.isModal === true) {
                            left = (windowWidth / 2) - angular.element(elm).prop("clientWidth") / 2 + "px";
                            top = (windowHeight / 2) - ((angular.element(elm).prop("clientHeight")) / 2) + "px"
                        } else {
                            if (containerWidth > elementWidth) {
                                if ((elementLeft > (containerWidth - elementWidth) / 2) && (elementLeft < (windowWidth - elementLeft) + containerWidth / 2))
                                    left = elementLeft - ((containerWidth - elementWidth) / 2);
                            } else
                                left = angular.element(element).prop("offsetLeft") + "px";

                            if ((elementTop - containerHeight) + 10 < 0) {
                                top = elementTop + elementHeight + 10 + "px";
                            } else
                                top = angular.element(elm).prop("clientHeight") + elementScrollTop - 10 + "px";
                        }
                        angular.element(elm).css("left", left);
                        angular.element(elm).css("top", top);

                        if (scope.isInTimeSelectMode === true)
                            scope.height = scope.calendarHeight;
                        else {
                            scope.height = "auto";
                            scope.calendarHeight = scope.settings.isModal === true ? containerHeight - 80 : containerHeight - 55;
                        }
                        return true;
                    } else
                        return $errors.add(ERROR_TYPE_DEFAULT, "krypton.ui -> dateTimePicker directive: Не задан параметр - HTML-элемент");
                };



                controller.$parsers.push(function(value) {
                    scope.$apply();
                    return value;
                });

                controller.$formatters.push(function(value) {
                    //$log.log("formatter value = ", value);
                    if (value === 0) {
                        //$log.log("formatter value = ", value);
                        if (scope.settings.noValue !== undefined) {
                            //$log.log("noValue = ", scope.settings.noValue);
                            return scope.settings.noValue;
                        } else
                            return moment.unix(value).format("DD MMM YYYY");
                    } else {
                        return scope.settings.isTimeEnabled === true ? moment.unix(value).format("DD MMM YYYY, HH:mm") : moment.unix(value).format(scope.settings.format);
                    }

                });





                scope.prev = function () {
                    if (scope.settings.isTimeEnabled === true && scope.isInTimeSelectMode === true) {
                        if (scope.isInMinutesSelectMode === false) {
                            if (scope.settings.isTroughNavigationEnabled === false) {
                                if (scope.value.hours() > 0 && scope.value.hours() <= 23)
                                    scope.value.subtract(1, "hours");
                                else if (scope.value.hours() === 0)
                                    scope.value.hours(23);
                            } else
                                scope.value.subtract(1, "hours");
                            //$log.log(scope.value.format("DD.MM.YYYY HH:mm"));
                        } else {
                            if (scope.settings.isTroughNavigationEnabled === false) {
                                if (scope.value.minutes() > 0 && scope.value.minutes() <= 59)
                                    scope.value.subtract(5, "minutes");
                                else if (scope.value.minutes() === 0)
                                    scope.value.minutes(55);
                            } else
                                scope.value.subtract(5, "minutes");
                            //$log.log(scope.value.format("DD.MM.YYYY HH:mm"));
                        }
                    } else {
                        scope.date.subtract(1, "months");
                        //$log.log("currentDate = " + scope.value.format("DD.MM.YYYY"));
                        scope.month = scope.date.month();
                        scope.year = scope.date.year();
                        recalculate(scope.date.month() + 1);
                    }
                };


                scope.next = function () {
                    if (scope.settings.isTimeEnabled === true && scope.isInTimeSelectMode === true) {
                        if (scope.isInMinutesSelectMode === false) {
                            if (scope.settings.isTroughNavigationEnabled === false) {
                                if (scope.value.hours() >= 0 && scope.value.hours() < 23)
                                    scope.value.add(1, "hours");
                                else if (scope.value.hours() === 23)
                                    scope.value.hours(0);
                            } else
                                scope.value.add(5, "minutes");
                        } else
                            scope.value.add(5, "minutes");
                    } else {
                        scope.date.add(1, "months");
                        moment(scope.date).day(1);
                        //$log.log("currentDate = " + moment(scope.date).format("DD.MM.YYYY"));
                        scope.month = moment(scope.date).month();
                        scope.year = moment(scope.date).year();
                        recalculate(scope.date.month() +1);
                    }
                };


                scope.select = function (value) {
                    if (value !== undefined) {
                        //$log.log("selected value = ", value);
                        if (value >= scope.settings.minDate && value <= scope.settings.maxDate) {
                            if (scope.settings.isTimeEnabled === true) {
                                if (scope.isInTimeSelectMode === false) {
                                    var temp = moment.unix(value).hours(0).minutes(0).seconds(0);
                                    scope.month = temp.month();
                                    scope.day = temp.date();
                                    scope.value.month(scope.month).date(scope.day).hours(0).minutes(0).seconds(0);
                                    controller.$setViewValue(scope.value.unix());
                                    //scope.ngModel = scope.value.unix();
                                    scope.isInTimeSelectMode = true;
                                    //$log.log(scope.value.format("DD.MM.YYYY HH:mm"), scope.value.unix());
                                    //scope.$apply();
                                } else {
                                    if (scope.isInMinutesSelectMode === false) {
                                        scope.value.hours(value).minutes(0).seconds(0);
                                        //scope.ngModel = scope.value.unix();
                                        controller.$setViewValue(scope.value.unix());
                                        scope.isInMinutesSelectMode = true;
                                        //$log.log(scope.value.format("DD.MM.YYYY HH:mm"), scope.value.unix());
                                    } else {
                                        scope.value.minutes(parseInt(value));
                                        //scope.ngModel = scope.value.unix();
                                        controller.$setViewValue(scope.value.unix());
                                        //$log.log(scope.value.format("DD.MM.YYYY HH:mm"), scope.value.unix());
                                        scope.close();
                                        //scope.$apply();
                                    }
                                }
                            } else {
                                var temp = moment.unix(value).hours(0).minutes(0).seconds(0);
                                scope.month = temp.month();
                                scope.day = temp.date();
                                scope.value.month(scope.month).date(scope.day).hours(0).minutes(0).seconds(0);
                                scope.ngModel = scope.value.unix();
                                controller.$setViewValue(scope.value.unix());
                                //$log.log(scope.value.format("DD.MM.YYYY HH:mm"), scope.value.unix());
                                scope.value = moment(new Date());
                                scope.close();
                                //scope.$apply();
                            }
                            if (scope.settings.onSelect !== undefined)
                                scope.settings.onSelect(scope.value.unix());
                        }

                    } else
                        $log.error("value = ", value);
                };


                var instance = $dateTimePicker.push(scope);
                var container = document.createElement("div");
                container.setAttribute("id", instance.id);
                container.className = "ui-date-time-picker2";
                if (scope.settings.isModal === true) {
                    container.classList.add("modal");
                    var fog = document.getElementsByClassName("krypton-ui-fog");
                    if (fog.length === 0) {
                        var fogElement = document.createElement("div");
                        fogElement.className = "krypton-ui-fog";
                        document.body.appendChild(fogElement);
                    }
                }
                container.innerHTML = template;
                document.body.appendChild(container);
                $compile(container)(scope);
                angular.element(element).css("cursor", "pointer");
                recalculate(scope.date.month() + 1);


                scope.open = function () {
                    if (scope.settings.isModal === true) {
                        var fog = document.getElementsByClassName("krypton-ui-fog");
                        document.body.style.overflow = "hidden";
                        fog[0].classList.add("visible");
                    }
                    angular.element(container).css("display", "block");
                    scope.settings.isOpened = true;
                    redraw(container);

                };


                scope.close = function () {
                    if (scope.settings.isModal === true) {
                        var fog = document.getElementsByClassName("krypton-ui-fog");
                        fog[0].classList.remove("visible");
                        document.body.style.overflow = "auto";
                    }
                    angular.element(container).css("display", "none");
                    scope.settings.isOpened = false;
                    scope.isInMinutesSelectMode = false;
                    scope.isInTimeSelectMode = false;
                    scope.value = new moment(new Date());
                    //scope.$apply();
                };


                container.addEventListener("DOMSubtreeModified", function () {
                    redraw(container);
                }, false);


                angular.element($window).bind("resize", function () {
                    redraw(container);
                });


                angular.element($document).bind("mousedown", function (event) {
                    if (scope.settings.isOpened === true && container.contains(event.target) === false && event.target !== element[0])
                        scope.close();
                });


                element.on("mousedown", function () {
                    if (scope.settings.isOpened === false)
                        scope.open();
                });


                element.on("keydown", function (event) {
                    event.preventDefault();
                });

                angular.element(angular.element(element).parent()).on("scroll", function () {
                    //$log.log("parent scrolled");
                    redraw(container);
                });
            }
        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiModalFooter", ["$log", "$sce", "$modals", function ($log, $sce, $modals) {
        return {
            restrict: "E",
            require: "^uiModal",
            link: function (scope, element, attrs, ctrl) {
                var height = 0;
                if (attrs.height !== undefined && attrs.height !== "")
                    height = parseInt(attrs.height);

                $log.log("ui modal footer");
                ctrl.registerFooter($sce.trustAsHtml(element[0].innerHTML), height);
                angular.element(element).remove();
            }
        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiModal", ["$log", "$sce", "$modals", function ($log, $sce, $modals) {
        return {
            restrict: "A",
            scope: false,
            controller: function ($scope, $element) {
                var footer = $scope.footer = {
                    content: undefined,
                    height: 0
                };

                this.registerFooter = function (content, height) {
                    $scope.footer.content = content;
                    $scope.footer.height = height;
                };

            },
            link: function (scope, element, attrs, ctrl) {
                $log.log("modal directive");

                if (attrs.modalId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "krypton.ui -> modal: Не задан идентификатор модального окна - аттрибут 'modal-id'");
                    return false;
                }


                var modal  = {
                    id: attrs.modalId,
                    isVisible: false,
                    caption: attrs.modalCaption !== undefined ? attrs.modalCaption : "",
                    content: $sce.trustAsHtml(element[0].innerHTML),
                    footer: scope.footer,
                    scope: scope,
                    width: attrs.modalWidth !== undefined && !isNaN(attrs.modalWidth) ? parseInt(attrs.modalWidth) : 0,
                    height: attrs.modalHeight !== undefined && !isNaN(attrs.modalHeight) ? parseInt(attrs.modalHeight) : 0,
                    onClose: attrs.modalOnClose !== undefined && typeof scope.$eval(attrs.modalOnClose) === "function" ? scope.$eval(attrs.modalOnClose) : undefined,
                    onOpen: attrs.modalOnOpen !== undefined && typeof scope.$eval(attrs.modalOnOpen) === "function" ? scope.$eval(attrs.modalOnOpen) : undefined
                };


                element[0].innerHTML = "";
                element[0].classList.add("ng-hide");
                $modals.register(modal);


                var check = document.getElementsByClassName("krypton-ui-modal");
                if (check.length === 0) {
                    var modal = document.createElement("div");
                    modal.className = "krypton-ui-modal";
                    var header = document.createElement("div");
                    header.className = "modal-header";
                    var headerCaption = document.createElement("span");
                    headerCaption.setAttribute("id", "krypton-ui-modal-caption");
                    headerCaption.className = "modal-caption";
                    var headerClose = document.createElement("span");
                    headerClose.className = "modal-close fa fa-times right";
                    headerClose.setAttribute("title", "Закрыть");
                    headerClose.setAttribute("ng-click", "modals.close()");
                    header.appendChild(headerCaption);
                    header.appendChild(headerClose);
                    var content = document.createElement("div");
                    content.setAttribute("id", "krypton-ui-modal-content");
                    content.className = "modal-content";
                    var footer = document.createElement("div");
                    footer.setAttribute("id", "krypton-ui-modal-footer");
                    footer.className = "modal-footer";
                    document.body.appendChild(modal);
                    modal.appendChild(header);
                    modal.appendChild(content);
                    modal.appendChild(footer);
                }


                var fog = document.getElementsByClassName("krypton-ui-fog");
                if (fog.length === 0) {
                    var fogElement = document.createElement("div");
                    fogElement.className = "krypton-ui-fog";
                    document.body.appendChild(fogElement);
                }
            }
        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiTab", ["$log", "$templateCache", "$errors", function ($log, $templateCache, $errors) {
        return {
            restrict: "E",
            require: "^uiTabs",
            link: function (scope, element, attrs, controller) {
                $log.log("tab directive");

                if (attrs.id === undefined || attrs.id === "") {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "ui-tab -> Не задан аттрибут - идентификатор вкладки");
                    return false;
                }

                var settings = scope.settings = {
                    id: attrs.id,
                    caption: attrs.caption !== undefined && attrs.caption !== "" ? attrs.caption : "",
                    icon: attrs.icon !== undefined && attrs.icon !== "" ? attrs.icon : undefined,
                    title: attrs.title !== undefined && attrs.title !== "" ? attrs.title : "",
                    content: element[0].innerHTML,
                    isActive: false
                };

                $templateCache.put("ui-tabs-" + controller.getId() + "-" + settings.id, settings.content);

                controller.registerTab(settings);
                element[0].innerHTML = "";
            }
        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiTabs", ["$log", "$templateCache", "$errors", "$tabs", function ($log, $templateCache, $errors, $tabs) {
        return {
            restrict: "E",
            transclude: true,
            scope: {
                onTabSelect: "="
            },
            replace: true,
            template: "<div class='ui-tabs'>" +
                        "<div ng-transclude></div>" +
                        "<div class='tabs-container'>" +
                            "<div class='ui-tab' ng-class='{ active: tab.isActive === true }' ng-repeat='tab in settings.tabs' ng-click='selectTab(tab.id)' title='{{ tab.title }}'>" +
                                "<span class='fa {{ tab.icon }}' ng-show='tab.icon !== undefined'></span>" +
                                "<span class='tab-caption'>{{ tab.caption }}</div>" +
                        "</div>" +
                        "<div class='tabs-content' id='tabs-content-{{settings.id}}' >" +
                            "<div ng-include='templateId' onload='onLoad()'></div>" +
                        "</div>" +
                      "</div>",
            controller: function ($scope, $element, $attrs) {
                if ($attrs.id === undefined || $attrs.id === "") {
                    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "ui-tabs -> Не задан аттрибут - идентификатор компонента");
                    return false;
                }

                var settings = $scope.settings = {
                    id: $attrs.id,
                    tabs: [],
                    content: "",
                    onTabSelect: $scope.onTabSelect !== undefined && typeof $scope.onTabSelect === "function" ? $scope.onTabSelect : undefined
                };
                var templateId = $scope.templateId = "ui-tabs-" + settings.id;

                $scope.onLoad = function () {
                    $log.info("template loaded");
                };

                var instance = $tabs.getById(settings.id);
                if (!instance) {
                    $tabs.register(settings);
                }


                this.getId = function () {
                    return settings.id;
                };

                this.registerTab = function (tab) {
                    if (tab === undefined) {
                        $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "ui-tabs -> registerTab: Не задан параметр - объект с настройками вкладки");
                        return false;
                    }

                    var length = settings.tabs.length;
                    for (var i = 0; i < length; i++) {
                        if (settings.tabs[i].id === tab.id) {
                            $errors.throw($errors.type.ERROR_TYPE_ENGINE, "ui-tabs -> registerTab: Вкладка с идентификатором '" + tab.id + "' уже существует");
                            return false;
                        } else
                            settings.tabs[i].isActive = false;
                    }

                    settings.tabs.push(tab);
                    settings.tabs[0].isActive = true;
                    $scope.templateId = "ui-tabs-" + settings.id + "-" + settings.tabs[0].id;
                    return true;
                };



                this.selectTab = $scope.selectTab = function (id) {
                    if (id === undefined) {
                        $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "ui-tabs -> selectTab: Не задан параметр - идентифкатор вкладки");
                        return false;
                    }

                    var length = settings.tabs.length;
                    for (var i = 0; i < length; i++) {
                        if (settings.tabs[i].id === id) {
                            settings.tabs[i].isActive = true;
                            $scope.templateId = "ui-tabs-" + settings.id + "-" + settings.tabs[i].id;
                        } else
                            settings.tabs[i].isActive = false;
                    }
                    return true;
                };
            },
            link: function (scope, element, attrs, transclude) {
                $log.log("tabs directive");
            }

        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiTimePicker", ["$log", function ($log) {
        return {
            restrict: "E",
            require: "ngModel",
            priority: 10,
            scope: {
                ngModel: "=",
                class: "@"
            },
            replace: true,
            template:
                "<div class='ui-time-picker {{ class }}'>" +
                    "<div class='time-picker-hours'><input type='text' maxlength='2' value='{{ hours }}'></div>" +
                    "<div class='time-picker-separator'>:</div>" +
                    "<div class='time-picker-minutes'><input type='text' maxlength='2' value='{{ minutes }}'></div>" +
                "</div>",
            link: function (scope, element, attrs, ngModel) {
                var date = 0;
                var hours = scope.hours = "00";
                var minutes = scope.minutes = "00";
                var previousHours = 0;
                var previousMinutes = 0;

                var hoursInput = angular.element(element.children()[0]).children()[0];
                var minutesInput = angular.element(element.children()[2]).children()[0];
                $log.log("hrs = ", hoursInput);
                $log.log("mns = ", minutesInput);

                scope.$watch("ngModel", function (val) {
                    $log.log("time model = ", val);
                });


                ngModel.$formatters.push(function (val) {
                    date = moment.unix(val);
                    $log.log("filter date = ", date.format("DD.MM.YYYY HH:mm"));
                    scope.hours = moment.unix(val).format("HH");
                    scope.minutes = moment.unix(val).format("mm");
                    return moment.unix(val).format("HH:mm");
                });


                ngModel.$parsers.push(function (val) {
                    $log.log("parser val = ", val);
                    return val;
                });


                angular.element(hoursInput).on("keydown", function (event) {
                    previousHours = angular.element(hoursInput).val();
                    $log.log("previousHours = ", previousHours);
                });


                angular.element(hoursInput).on("keyup", function () {
                    //var exp = new RegExp("^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5]?[0-9]$");
                    var exp = new RegExp("^([0-9]|0[0-9]|1[0-9]|2[0-3])$");
                    if (exp.test(angular.element(hoursInput).val())) {
                        $log.log("hours accepted");
                        date.hours(parseInt(angular.element(hoursInput).val()));
                        //ngModel.$modelValue = date.unix();
                        ngModel.$setViewValue(date.unix());
                        //scope.minutes = moment.unix(date).format("mm");
                        $log.info(ngModel);
                        scope.$apply();
                    } else {
                        $log.log("shit");
                        //ngModel.$setViewValue(previousHours);
                        //$log.log("rec $viewValue = ", ngModel.$viewValue);
                    }
                });


                angular.element(minutesInput).on("keydown", function (event) {
                    previousMinutes = angular.element(minutesInput).val();
                    $log.log("previousMinutes = ", previousMinutes);
                });


                angular.element(minutesInput).on("keyup", function () {
                    //var exp = new RegExp("^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5]?[0-9]$");
                    var exp = new RegExp("^(0|[0-5]?[0-9])$");
                    if (exp.test(angular.element(minutesInput).val())) {
                        $log.log("minutes accepted");
                        date.minutes(parseInt(angular.element(minutesInput).val()));
                        ngModel.$setViewValue(date.unix());
                        angular.element(minutesInput).val(moment.unix(date).format("mm"));
                        $log.info(ngModel);
                    } else {
                        $log.log("shit");
                        angular.element(minutesInput).val(previousMinutes);
                        //ngModel.$setViewValue(element.val());
                        //$log.log("rec $viewValue = ", ngModel.$viewValue);
                    }
                });
            }
        }
    }]);
angular
    .module("homunculus.ui")
    .directive("uiTree", ["$log", "$templateCache", "$errors", "$tree", function ($log, $templateCache, $errors, $tree) {

        var template =
            "<div class='container nested'>" +
            "<div class=\"tree-item\" ng-show='node.isVisible !== false' ng-class='{ \"with-children\": node.childrenCount > 0, \"expanded\": node.isExpanded === true && node.childrenCount > 0, \"active\": node.isSelected === true }' ng-repeat=\"node in node.children | toArray | orderBy: \'order\' track by $index\">" +
            "<div class='tree-item-content' ng-click='expand(node)'>" +
            "<div class='item-label' ng-class='{ \"active\": node.isSelected === true }' ng-click='select(node, $event)'>" +
            "<span>{{ node.display }}</span>" +
            "</div>" +
            "<div class='item-controls'>" +
            "<span class='expand fa fa-chevron-down' ng-click='expand(node)' ng-show='node.childrenCount > 0 && node.isExpanded == false'></span>" +
            "<span class='collapse fa fa-chevron-up' ng-if='node.isExpanded === true' ng-click='collapse(node)'></span>" +
            "</div>" +
            "<div class='item-notifications' ng-show='tree.showNotifications == true && node.notifications.items.length > 0'>" +
            "<div class='notification {{ notification.class }}' ng-repeat='notification in node.notifications.items track by $index' ng-show='notification.isVisible === true'>" +
            "<span class='fa {{ notification.icon }} notification.class' ng-show='notification.icon !== \"\"'></span>" +
            "<span class='value'>{{ notification.value }}</span>" +
            "</div>" +
            "</div>" +
            "</div>" +
            "<div ng-show='node.isExpanded === true' ng-include=\"\'tree'\"></div>" +
            "</div>" +
            "</div>";

        return {
            restrict: "E",
            scope: {
                class: "@"
            },
            template:
            "<div class='{{ \"krypton-ui-tree \" + class }}'>" +
            "<div class='container root'>" +
            "<div class='tree-item' ng-show='node.isVisible !== false' ng-class='{ \"with-children\": node.childrenCount > 0, \"expanded\": node.isExpanded === true, \"active\": node.isSelected === true }' ng-repeat='node in initial | toArray | orderBy:\"order\" track by $index'>" +
            "<div class='tree-item-content' ng-click='expand(node)'>" +
            "<div class='item-label' ng-class='{ active: node.isSelected === true }' ng-click='select(node, $event)'>" +
            "<span>{{ node.display }}</span>" +
            "</div>" +
            "<div class='item-controls'>" +
            "<span class='expand fa fa-chevron-down' ng-click='expand(node)' ng-show='node.childrenCount > 0 && node.isExpanded === false'></span>" +
            "<span class='collapse fa fa-chevron-up' ng-if='node.isExpanded === true' ng-click='collapse(node)'></span>" +
            "</div>" +
            "<div class='item-notifications' ng-show='tree.showNotifications === true && node.notifications.items.length > 0'>" +
            "<div class='notification {{ notification.class }}' ng-repeat='notification in node.notifications.items track by $index' ng-show='notification.isVisible === true'>" +
            "<span class='fa {{ notification.icon }}' ng-show='notification.icon !== \"\"'></span>" +
            "<span class='value'>{{ notification.value }}</span>" +
            "</div>" +
            "</div>" +
            "</div>" +
            "<div ng-include=\"\'tree'\" ng-show='node.isExpanded === true'></div>" +
            "</div>" +
            "</div>" +
            "</div>",
            link: function (scope, element, attrs) {

                if (attrs.id === undefined || attrs.id === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (attrs.rootKey === undefined || attrs.rootKey === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - значение коюча корневого элемента дерева");
                    return false;
                }

                if (attrs.rootKeyDataType === undefined || attrs.rootKeyDataType === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - тип данных коюча корневого элемента дерева");
                    return false;
                }

                var root = 0;
                switch (attrs.rootKeyDataType) {
                    case "DATA_TYPE_INTEGER":
                        if (isNaN(parseInt(attrs.rootKey))) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Значение ключа корневого элемента не соответствует типу данных коючевого элемента");
                            return false;
                        }
                        root = parseInt(attrs.rootKey);
                        break;
                    case "DATA_TYPE_FLOAT":
                        if (isNaN(parseFloat(attrs.rootKey))) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Значение ключа корневого элемента не соответствует типу данных коючевого элемента");
                            return false;
                        }
                        root = parseFloat(attrs.rootKey);
                        break;
                    case "DATA_TYPE_STRING":
                        root = attrs.rootKey.toString();
                        break;
                    default:
                        $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Неверно задан тип данных корневого элемента");
                        return false;
                        break;
                }


                var initial = scope.initial = {};
                var stack = scope.stack = {};

                $templateCache.put("tree", template);
                var tree = $tree.getById(attrs.id);
                if (tree !== false) {
                    scope.initial = tree.initial;
                    scope.stack = tree.stack;
                    scope.tree = tree;
                } else {
                    $tree.register({
                        id: attrs.id,
                        rootKey: root,
                        expandOnSelect: attrs.expandOnSelect !== undefined ? true : false,
                        collapseOnDeselect: attrs.collapseOnDeselect !== undefined ? true : false
                    });
                    scope.tree = $tree.getById(attrs.id);
                }



                scope.select = function (item, event) {
                    event.stopPropagation();
                    if (item !== undefined) {
                        if (!$tree.selectItem(attrs.id, item.key)) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> '" + attrs.id + "' select: Не удалось выбрать элемент с идентификатором " + item.key);
                            return false;
                        }
                        return true;
                    }
                };



                scope.expand = function (item) {
                    if (item !== undefined) {
                        $log.log(item);
                        if (item.isExpanded == false) {
                            if (!$tree.expandItem(attrs.id, item.key)) {
                                $errors.add(ERROR_TYPE_ENGINE, "structure directive -> expand: не удвлось развернуть элемент с идентификатором " + item.key);
                                return false;
                            }
                        } else {
                            if (!$tree.collapseItem(attrs.id, item.key)) {
                                $errors.add(ERROR_TYPE_ENGINE, "structure directive -> expand: Не удалось свернуть элемент с идентификатором " + item.key);
                                return false;
                            }
                        }
                        return true;
                    }
                };

            }
        }
    }]);

    $classesInjector.add("AppUser", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        divisionId: new Field({ source: "DIVISION_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        surname: new Field({ source: "SURNAME", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        name: new Field({ source: "NAME", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        fname: new Field({ source: "FNAME", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        email: new Field({ source: "EMAIL", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        login: new Field({ source: "LOGIN", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        password: new Field({ source: "PASSWORD", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        isAdministrator: new Field({ source: "IS_ADMINISTRATOR", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        allowEdit: new Field({ source: "ALLOW_EDIT", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        allowConfirm: new Field({ source: "ALLOW_CONFIRM", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        isLDAPEnabled: new Field({ source: "IS_LDAP_ENABLED", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true })
    });
/******************************
 * Backup
 * Набор свойств и методов, реализующих резервное копирование данных объекта
 ******************************/
$classesInjector.add("Backup", {
    __dependencies__: [],
    _backup_: {
        __instance__: "",
        data: {},

        /**
         * Устанавливает резервные значения для полей, помеченных для бэкапа
         * @returns {number} - Возвращает количество полей, для короых созданы резервные значения
         */
        setup: function () {
            var result = 0;
            for (var prop in this.__instance__) {
                if (this.__instance__[prop].constructor === Field && this.__instance__[prop].backupable !== undefined && this.__instance__[prop].backupable === true && this.__instance__[prop] !== null) {
                    if (this.__instance__[prop].type !== undefined) {
                        switch (parseInt(this.__instance__[prop].type)) {
                            case DATA_TYPE_STRING:
                                this.data[prop] = this.__instance__[prop].value.toString();
                                break;
                            case DATA_TYPE_INTEGER:
                                this.data[prop] = parseInt(this.__instance__[prop].value);
                                break;
                            case DATA_TYPE_FLOAT:
                                this.data[prop] = +parseFloat(this.__instance__[prop].value).toFixed(6);
                                break;
                            case DATA_TYPE_BOOLEAN:
                                this.data[prop] = this.__instance__[prop].value;
                                break;
                        }
                    } else {
                        this.data[prop] = this.__instance__[prop].value;
                        result++;
                    }
                }
            }
            if (this.__instance__._init_ !== undefined)
                this.__instance__._init_();
            return result;
        },

        /**
         * Восстанавливает резервные значения полей, занесенных в бэкап
         * @returns {number} Возвращает количество полей, для которых восстановлены резервные значения
         */
        restore: function () {
            var result = 0;
            for (var prop in this.data) {
                if (this.__instance__[prop] !== undefined &&
                    this.__instance__[prop].constructor === Field &&
                    this.__instance__[prop].backupable === true) {
                    this.__instance__[prop].value = this.data[prop];
                    result++;
                }
            }
            if (this.__instance__.onInitModel !== undefined)
                this.__instance__.onInitModel();
            if (this.__instance__.onRestoreBackup !== undefined && typeof (this.__instance__.onRestoreBackup === "function"))
                this.__instance__.onRestoreBackup();
            return result;
        },

        toString: function () {
            return JSON.stringify(this.data);
        }
    }
});

/******************************
 * Collection
 * Набор свойств и методов, описывающих коллекцию элементов
 ******************************/
$classesInjector.add("Collection", {
    items: [],
    selectedItems: [],
    allowMultipleSelect: false,
    allowMultipleSearch: false,

    /**
     * Возвращает количество элементов в коллекции
     * @returns {Number} - Возвращает размер коллекции
     */
    size: function () {
        return this.items.length;
    },

    /**
     * Выводит в консоль все элементы коллекции
     * @returns {Number} - Возвращает количество элементов в коллекции
     */
    display: function () {
        var result = this.items.length;
        if (console !== undefined) {
            console.log(this.items);
        }
        return result;
    },

    /**
     * Включает / выключает режим поиска нескольких элементов коллекции
     * @param flag {boolean} - Флаг, включения / выключения режима поиска нескольких элементов коллекции
     * @returns {boolean} - Возвращает флаг, включен ли режим поиска нескольких элементов коллекции
     */
    multipleSearch: function (flag) {
        var result = false;
        if (flag !== undefined) {
            if (flag.constructor === Boolean) {
                this.allowMultipleSearch = flag;
                result = this.allowMultipleSearch;
            } else
                $log.error("$classes 'Collection': Параметр должен быть типа Boolean");
        } else
            $log.error("$classes 'Collection': Не указан параметр при установке режима поиска нескольких элементов");
        return result;
    },

    /**
     * Возвращает элемент коллекции, поле field которого равен value
     * @param field {String} - Наименование поля
     * @param value - Значение искомого поля
     * @returns {boolean/Any} - Возвращает искомый элемент коллекции, в противном случае false
     */
    find: function (field, value) {
        var result = false;
        var temp_result = [];
        var length = this.items.length;

        /* Если требуется найти элемент коллекции по значению поля */
        if (field !== undefined && value !== undefined) {
            //console.log("finding item by field and value");
            for (var i = 0; i < length; i++) {
                if (this.items[i][field] !== undefined) {
                    if (this.items[i][field].constructor === Field) {
                        if (this.items[i][field].value === value) {
                            if (this.allowMultipleSearch === true) {
                                temp_result.push(this.items[i]);
                            } else {
                                temp_result.splice(0, temp_result.length);
                                temp_result.push(this.items[i]);
                                result = this.items[i];
                            }
                        }
                    } else {
                        if (this.items[i][field] === value) {
                            if (this.allowMultipleSearch === true) {
                                temp_result.push(this.items[i]);
                            } else {
                                temp_result.splice(0, temp_result.length);
                                temp_result.push(this.items[i]);
                                result = this.items[i];
                            }
                        }
                    }
                }
            }
        }

        /* Если требуется найти элемент коллекции по значению */
        if (field !== undefined && value === undefined) {
            //console.log("finding item by value");
            for (var i = 0; i < length; i++) {
                if (this.items[i] === field) {
                    if (this.allowMultipleSearch === true) {
                        temp_result.push(this.items[i]);
                        result = this.items[i];
                    } else {
                        temp_result.splice(0, temp_result.length);
                        temp_result.push(this.items[i]);
                    }
                }
            }
        }

        if (temp_result.length === 0)
            return false;
        else if (temp_result.length === 1)
            return temp_result[0];
        else if (temp_result.length > 1)
            return temp_result;
    },


    /**
     * Добавляет элемент в конец коллекции
     * @param item {Any} - Элемент, добавляемый в коллекцию
     * @returns {boolean / Number} - Возвращает новую длину коллекции, false в случае некорректного завершения
     */
    append: function (item) {
        var result = false;
        if (item !== undefined) {
            this.items.push(item);
        }
        return item;
    },

    /**
     * Удаляет элементы по значению поля и по значению
     * @param field {String} - Наименование поля
     * @param value {Any} - Значение поля
     * @returns {Number} - Возвращает количество удаленных элементов
     */
    delete: function (field, value) {
        var result = 0;
        var length = this.items.length;

        /* Если требуется удалить элементы коллекции по полю и его значению */
        if (field !== undefined && value !== undefined) {
            console.log("deleting by field and value");
            for (var i = 0; i < this.items.length; i++) {
                if (this.items[i][field] !== undefined) {
                    if (this.items[i][field].constructor === Field) {
                        if (this.items[i][field].value === value) {
                            this.items.splice(i, 1);
                            result++;
                        }
                    } else {
                        if (this.items[i][field] === value) {
                            this.items.splice(i, 1);
                            result++;
                        }
                    }
                }
            }
        }

        /* Если требуется удалить элементы по значению */
        if (field !== undefined && value === undefined) {
            console.log("deleting by value");
            for (var i = 0; i < length; i++) {
                if (this.items[i] === field) {
                    this.items.splice(i, 1);
                    result++;
                }
            }
        }

        return result;
    },

    /**
     *
     */
    clear: function () {
        this.items.splice(0, this.items.length);
        return true;
    },

    /**
     * Включает / выключает режим выбора нескольких элементов коллекции
     * @param flag {boolean} - Флаг включения / выключения режима выбора нескольких элементов коллекции
     * @returns {boolean} - Возвращает флаг, включен ли режим выбора нескольких элементов коллекции
     */
    multipleSelect: function (flag) {
        if (flag !== undefined) {
            if (flag.constructor === Boolean) {
                this.allowMultipleSelect = flag;
                return this.allowMultipleSelect;
            } else
                $log.error("$classes 'Collection': Параметр должен быть типа Boolean");
        } else
            $log.error("$classes 'Collection': Не указан параметр при установке режима выбора нескольких элементов");
    },

    /**
     * Помечает элемент коллекции как выбранный
     * @param field {string} - Наименование поля элемента коллекции
     * @param value {any} - Значение поля элемента коллекции
     * @returns {number}
     */
    select: function (field, value) {
        var result = [];
        if (field !== undefined && value !== undefined) {
            var length = this.items.length;
            for (var i = 0; i < length; i++) {
                if (this.items[i].hasOwnProperty(field)) {
                    var item = undefined;
                    if (this.items[i][field].constructor === Field) {
                        if (this.items[i][field].value === value) {
                            console.log("element found", this.items[i]);
                            item = this.items[i];
                        }
                    } else {
                        if (this.items[i][field] === value)
                            item = this.items[i];
                    }
                    if (item !== undefined) {
                        if (this.allowMultipleSelect === true) {
                            result.push(item);
                            this.selectedItems.push(item);
                            if (item._states_ !== undefined)
                                item._states_.selected(true);
                        } else {
                            result.splice(0, result.length);
                            this.selectedItems.splice(0, this.selectedItems.length);
                            result.push(this.items[i]);
                            this.selectedItems.push(this.items[i]);
                            if (item._states_ !== undefined)
                                item._states_.selected(true);
                            for (var x = 0; x < length; x++) {
                                if (this.items[x] !== item) {
                                    if (this.items[x]._states_ !== undefined)
                                        this.items[x]._states_.selected(false);
                                }
                            }
                        }
                    }
                }
            }
        }

        console.log("selectedItems = ", this.selectedItems);

        if (result.length === 0)
            return false;
        if (result.length === 1)
            return result[0];
        if (result.length > 1)
            return result;

    },

    deselect: function (item) {
        if (item !== undefined) {
            var length = this.items.length;
            for (var i = 0; i < length; i++) {
                if (this.items[i] === item) {
                    var selectedLength = this.selectedItems.length;
                    if (item._states_ !== undefined)
                        item._states_.selected(false);
                    for (var x = 0; x < selectedLength; x++) {
                        if (this.selectedItems[x] === item) {
                            this.selectedItems.splice(x, 1);
                        }
                    }
                }
            }
        }
        console.log(this.selectedItems);
        return this.selectedItems;
    }
});


/**
 * Error
 * Набор свойств и методов, описывающий ошибку
 */

$classesInjector.add("Error", {
 __dependencies__: [],
 type: new Field({ source: "typeId", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
 message: new Field({ source: "message", type: DATA_TYPE_STRING, value: "", default_value: "" }),
 timestamp: new Field({ source: "timestamp", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 })
 });


/**
 * File
 * Набор свойств и методов, описывающих файл
 */
$classesInjector.add("File", {
    _dependencies__: [],
    title: new Field({ source: "title", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
    type: new Field({ source: "type", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
    size: new Field({ source: "size", type: DATA_TYPE_INTEGER, default_value: 0, value: 0, backupable: true, displayable: true }),
    url: new Field({ source: "url", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true })
});
$classesInjector
    .add("MenuItem", {
        id: "",
        parentId: "",
        order: 0,
        url: "",
        icon: "",
        title: "",
        description: "",
        isActive: false,
        isParentActive: false,
        isVisible: true
    });

/********************
 * Model
 * Набор свойст и методов, описывающих модель данных
 ********************/
$classesInjector.add("Model", {
    __dependencies__: [],
    _model_: {
        __instance__: "",
        _errors_: [],
        db_table: "",

        /**
         * Производит инициализацию модели данных на основе JSON-данных
         * @param JSONdata {JSON} - Набор JSON-данных
         * @returns {number} - Возвращает количество полей, проинициализированных из JSON-данных
         */
        fromJSON: function (JSONdata) {
            var result = 0;
            for (var data in JSONdata) {

                for (var prop in this.__instance__) {

                    if (this.__instance__[prop].constructor === Field && this.__instance__[prop].source === data) {

                        if (JSONdata[data] !== "") {

                            if (this.__instance__[prop].type !== undefined) {
                                switch (this.__instance__[prop].type) {
                                    case DATA_TYPE_STRING:
                                        this.__instance__[prop].value = JSONdata[data].toString();
                                        this.__instance__[prop]._backup_(JSONdata[data].toString());
                                        break;
                                    case DATA_TYPE_INTEGER:
                                        if (!isNaN(JSONdata[data])) {
                                            this.__instance__[prop].value = parseInt(JSONdata[data]);
                                            this.__instance__[prop]._backup_(parseInt(JSONdata[data]));
                                        } else {
                                            $log.error("$classes [Model]: Значение поля '" + data + "' в наборе JSON-данных не является числовым значением, свойству объекта присвоен 0");
                                            this.__instance__[prop].value = 0;
                                            this.__instance__[prop]._backup_(0);
                                        }
                                        break;
                                    case DATA_TYPE_FLOAT:
                                        if (!isNaN(JSONdata[data])) {
                                            this.__instance__[prop].value = +parseFloat(JSONdata[data]).toFixed(6);
                                            this.__instance__[prop]._backup_(+parseFloat(JSONdata[data]).toFixed(6));
                                        } else {
                                            $log.error("$classes [Model]: Значение поля '" + data + "' в наборе JSON-данных не является числовым значением, свойству объекта присвоен 0");
                                            this.__instance__[prop].value = 0.0;
                                            this.__instance__[prop]._backup_(0.0);
                                        }
                                        break;
                                    case DATA_TYPE_BOOLEAN:
                                        if (!isNaN(JSONdata[data])) {
                                            var value = parseInt(JSONdata[data]);
                                            if (value === 1 || value === 0) {
                                                this.__instance__[prop].value = value === 1 ? true : false;
                                                this.__instance__[prop]._backup_(this.__instance__[prop].value);
                                            } else {
                                                $log.error("$classes [Model]: Значение поля '" + data + "' в наборе JSON-данных не является интрепретируемым в логическое значение, свойству объекта присвоен false");
                                                this.__instance__[prop].value = false;
                                                this.__instance__[prop]._backup_(false);
                                            }
                                        } else {
                                            var value = JSONdata[data].toString().toLowerCase();
                                            if (value === "true" || value === "false") {
                                                this.__instance__[prop].value = value === "true" ? true : false;
                                                this.__instance__[prop]._backup_(this.__instance__[prop].value);
                                            } else {
                                                $log.error("$classes [Model]: Значение поля '" + data + "' в наборе JSON-данных не является интрепретируемым в логическое значение, свойству объекта присвоен false");
                                                this.__instance__[prop].value = false;
                                                this.__instance__[prop]._backup_(false);
                                            }
                                        }
                                        break;
                                }
                            } else {
                                /* Для совместимости */
                                if (isNaN(JSONdata[data]) === false) {
                                    if (JSONdata[data] !== null) {

                                        if (JSONdata[data].constructor === Boolean) {
                                            this.__instance__[prop].value = JSONdata[data];
                                        } else
                                            this.__instance__[prop].value = parseInt(JSONdata[data]);

                                    }
                                } else {
                                    this.__instance__[prop].value = JSONdata[data];
                                }
                            }
                        } else
                            this.__instance__[prop].value = "";

                        result++;
                    }

                }

            }
            if (this.__instance__["onInitModel"] !== undefined) {
                if (this.__instance__["onInitModel"].constructor === Function) {
                    this.__instance__.onInitModel();
                }
            }
            return result;
        },


        /**
         * Производит инициализацию модели данных на основе другого объекта, копируя значения совпадающих свойств
         * @param obj {object} - Объект, на основе которого требуется произвести инициализацию
         */
        fromAnother: function (obj) {
            if (obj === undefined) {
                $errors.add(ERROR_TYPE_DEFAULT, "Model -> fromAnother: Не задан параметр - объект, на основе которого трекуется провести инициализацию");
                return false;
            } else {

                for (var anotherProp in obj) {
                    if (obj[anotherProp] === null) {
                        $log.info("Model -> fromAnother: Отсутствует значение (null) свойста '" + anotherProp + "' объекта, на основе которого требуется провести инициализаццию");
                        return false;
                    } else {

                        if (this.__instance__.hasOwnProperty(anotherProp)) {
                            if (isField(this.__instance__[anotherProp])) {
                                if (this.__instance__[anotherProp].type !== undefined) {
                                    switch (this.__instance__[anotherProp].type) {
                                        case DATA_TYPE_STRING:
                                            if (isField(obj[anotherProp])) {
                                                this.__instance__[anotherProp]._fromAnother_(obj[anotherProp]);
                                                this.__instance__[anotherProp]._backup_(obj[anotherProp].value.toString());
                                            } else {
                                                this.__instance__[anotherProp].value = obj[anotherProp].toString();
                                                this.__instance__[anotherProp]._backup_(obj[anotherProp].toString());
                                            }
                                            break;
                                        case DATA_TYPE_INTEGER:
                                            var value = isField(obj[anotherProp]) ? obj[anotherProp].value : obj[anotherProp];


                                            if (!isNaN(value)) {
                                                if (isField(obj[anotherProp])) {
                                                    this.__instance__[anotherProp]._fromAnother_(obj[anotherProp]);
                                                    this.__instance__[anotherProp]._backup_(parseInt(obj[anotherProp].value));
                                                } else {
                                                    this.__instance__[anotherProp].value = parseInt(obj[anotherProp]);
                                                    this.__instance__[anotherProp]._backup_(parseInt(obj[anotherProp]));
                                                }
                                            } else {
                                                $log.info("$classes -> Model: Значение поля '" + anotherProp + "' в наборе JSON-данных не является числовым значением, свойству объекта присвоен 0");
                                                this.__instance__[anotherProp].value = 0;
                                                this.__instance__[anotherProp]._backup_(0);
                                            }
                                            break;
                                        case DATA_TYPE_FLOAT:
                                            if (!isNaN(obj[anotherProp])) {
                                                if (isField(obj[fromAnother()])) {
                                                    this.__instance__[anotherProp]._fromAnother_(obj[anotherProp]);
                                                    this.__instance__[anotherProp]._backup_(+parseFloat(obj[anotherProp].value).toFixed(6));
                                                } else {
                                                    this.__instance__[anotherProp].value = +parseFloat(obj[anotherProp]).toFixed(6);
                                                    this.__instance__[anotherProp]._backup_(+parseFloat(obj[anotherProp]).toFixed(6));
                                                }
                                            } else {
                                                $log.info("$classes -> Model: Значение поля '" + anotherProp + "' в наборе JSON-данных не является числовым значением, свойству объекта присвоен 0");
                                                this.__instance__[anotherProp].value = 0.0;
                                                this.__instance__[anotherProp]._backup_(0.0);
                                            }
                                            break;
                                        case DATA_TYPE_BOOLEAN:
                                            if (!isNaN(obj[anotherProp])) {
                                                var value = isField(obj[anotherProp]) ? parseInt(obj[anotherProp].value) : parseInt(obj[anotherProp]);
                                                if (value === 1 || value === 0) {
                                                    this.__instance__[anotherProp].value = value === 1 ? true : false;
                                                    this.__instance__[anotherProp]._backup_(this.__instance__[anotherProp].value);
                                                } else {
                                                    $log.info("$classes -> Model: Значение поля '" + anotherProp + "' в наборе JSON-данных не является интрепретируемым в логическое значение, свойству объекта присвоен false");
                                                    this.__instance__[anotherProp].value = false;
                                                    this.__instance__[anotherProp]._backup_(false);
                                                }
                                            } else {
                                                var value = isField(obj[anotherProp]) ? obj[anotherProp].value.toString().toLowerCase() : obj[anotherProp].toString().toLowerCase();

                                                if (value === "true" || value === "false") {
                                                    this.__instance__[anotherProp].value = value === "true" ? true : false;
                                                    this.__instance__[anotherProp]._backup_(this.__instance__[anotherProp].value);
                                                } else {
                                                    $log.info("$classes -> Model: Значение поля '" + anotherProp + "' в наборе JSON-данных не является интрепретируемым в логическое значение, свойству объекта присвоен false");
                                                    this.__instance__[anotherProp].value = false;
                                                    this.__instance__[anotherProp]._backup_(false);
                                                }
                                            }
                                            break;
                                    }

                                } else {
                                    if (isField(obj[anotherProp])) {
                                        this.__instance__[anotherProp].value = obj[anotherProp].value;
                                        this.__instance__[anotherProp]._backup_(obj[anotherProp].value);
                                    } else {

                                        this.__instance__[anotherProp].value = obj[anotherProp];
                                        this.__instance__[anotherProp]._backup_(obj[anotherProp]);
                                    }
                                }

                            } else {
                                if (isField(obj[anotherProp]))
                                    this.__instance__[anotherProp] = obj[anotherProp].value;
                                else
                                    this.__instance__[anotherProp] = obj[anotherProp];
                            }
                        }
                    }
                }
            }

            if (this.__instance__["onInitModel"] !== undefined) {
                if (this.__instance__["onInitModel"].constructor === Function) {
                    this.__instance__.onInitModel();
                }
            }
        },


        /**
         * Возвращает значения полей модели данных в виде строки
         * @returns {string} - Возвращает значения полей модели в виде строки
         */
        toString: function () {
            var result = {};
            for (var prop in this.__instance__) {
                if (this.__instance__[prop].constructor === Field) {
                    result[prop] = this.__instance__[prop];
                }
            }
            return JSON.stringify(result);
        },


        /**
         * Производит сброс значений полей модели данных к значениям по умолчанию
         * @returns {number} - Возвращает количество полей, чьи значения были установлены в значение по
         *                      умолчанию
         */
        reset: function () {
            var result = 0;
            for (var prop in this.__instance__) {
                if (this.__instance__[prop].constructor === Field &&
                    this.__instance__[prop].default_value !== undefined) {
                    this.__instance__[prop].value = this.__instance__[prop].default_value;
                    result++;
                }
            }
            return result;
        },


        _init_: function () {
            for (var prop in this.__instance__) {
                if (this.__instance__[prop].constructor === Field &&
                    this.__instance__[prop].default_value !== undefined) {
                    this.__instance__[prop].value = this.__instance__[prop].default_value;
                }
            }
        }
    }
});
/**
 * Setting
 * Класс, описывающий настройку приложения
 */
$classesInjector.add("Setting", {
    code: new Field({ source: "CODE", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
    type: new Field({ source: "DATA_TYPE", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
    title: new Field({ source: "TITLE", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
    description: new Field({ source: "DESCRIPTION", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
    value: new Field({ source: "VALUE", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),

    _onConstruct: function () {
        if (this.value.value !== undefined && this.value.value !== null && this.value.value !== "") {
            switch (this.type.value) {
                case DATA_TYPE_INTEGER:
                    if (isNaN(this.value.value)) {
                        console.info("$settings -> " + this.title.value + " - значание настройки не соответствует типу данных, присвоен 0");
                        this.value.value = 0;
                    } else {
                        this.value.value = parseInt(this.value.value);
                        this.value.type = DATA_TYPE_INTEGER;
                    }
                    break;
                case DATA_TYPE_FLOAT:
                    if (isNaN(this.value.value)) {
                        console.info("$settings -> " + this.title.value + " - значание настройки не соответствует типу данных, присвоен 0");
                        this.value.value = 0;
                    } else {
                        this.value.value = parseFloat(this.value.value);
                        this.value.type = DATA_TYPE_FLOAT;
                    }
                    break;
                case DATA_TYPE_STRING:
                    this.value.value = this.value.value.toString();
                    break;
                case DATA_TYPE_BOOLEAN:
                    if (isNaN(this.value.value) && parseInt(this.value.value) !== 0 && parseInt(this.value.value) !== 1) {
                        console.info("$settings -> " + this.title.value + " - значение настройки не соответствует типу данных, присвоен false");
                        this.value.value = false;
                    } else {
                        this.value.value = new Boolean(parseInt(this.value.value));
                        this.value.type = DATA_TYPE_BOOLEAN;
                    }
                    break;
                default:
                    console.info("$settings -> " + this.title.value + " - тип данных настройки задан некорректно");
                    break;
            }
        }
    }
});
/******************************
 * States
 * Набор свойст и методов, описывающих состояние объекта
 ******************************/

$classesInjector.add("States", {
    __dependencies__: [],
    _states_: {
        isActive: false,        // Флаг, сигнализирующий, активен ли объект
        isSelected: false,      // Флаг, сигнализирующий, выбран ли объект
        isChanged: false,       // Флаг, сигнализирующий, был ли изменен объект
        isLoaded: true,         // Флаг, сигнализирующий был ли объект загружен
        isLoading: false,       // Флаг, сигнализирующий, находится ли объект в режиме загрузки
        isInEditMode: false,    // Флаг, сигнализирующий, находится ли объект в режиме редактирования
        isInDeleteMode: false,  // Флаг, сигнализирующий, находится ли объект в режиме удаления

        /**
         * Устанавливает / отменяет режим активного объекта
         * @param flag {Boolean} - Флаг активности / неактивности объекта
         * @returns {boolean} - Возвращает флаг активности / неактивности объекта
         */
        active: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isActive = flag;
            return this.isActive;
        },

        /**
         * Устанавливает / отменяет режим редактирования объекта
         * @param flag {Boolean} - Флаг нахождения объекта в режиме редактирования
         * @returns {boolean} - Возвращает флаг нахождения объекта в режиме редактирования
         */
        editing: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isInEditMode = flag;
            return this.isInEditMode;
        },

        /**
         * Устанавливает / отменяет режим удаления объекта
         * @param flag {boolean} - Флаг нахождения объекта в режиме удаления
         * @returns {boolean} - Возвращает флаг нахождения объекта в режиме удаления
         */
        deleting: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isInDeleteMode = flag;
            return this.isInDeleteMode;
        },

        /**
         * Устанавливает / отменяет режим измененного объекта
         * @param flag {boolean} - Флаг, был ли объект изменен
         * @returns {boolean} - Возвращает флаг, был ли объект изменен
         */
        changed: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isChanged = flag;
            return this.isChanged;
        },

        /**
         * Устанавливает / отменяет режим выбранного объекта
         * @param flag {boolean} - Флаг, был ли выбран объект
         * @returns {boolean} - Возвращает флаг, был ли выбран объект
         */
        selected: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean) {
                this.isSelected = flag;
                //console.log("selected = ", this.isSelected);
            }
            return this.isSelected;
        },

        /**
         * Устанавливает / отменяет режим загруженного объекта
         * @param flag {boolean} - Флаг, был ли объект загружен
         * @returns {boolean} - Возвращает флаг, был ли объект загружен
         */
        loaded: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isLoaded = flag;
            return this.isLoaded;
        },

        /**
         * Устанавливает / отменяет режим загруженного объекта
         * @param flag {boolean} - Флаг, был ли объект загружен
         * @returns {boolean} - Возвращает флаг, был ли объект загружен
         */
        loading: function (flag) {
            if (flag !== undefined && flag.constructor === Boolean)
                this.isLoading = flag;
            return this.isLoading;
        }
    }
});
$classesInjector.add("TreeItem", {
        key: 0,
        parentKey: 0,
        display: "",
        children: {},
        childrenCount: 0,
        order: 0,
        data: {},
        isExpanded: false,
        isSelected: false,
        isChecked: false,
        isVisible: true,
        notifications: {
            items: [],

            add: function (parameters) {
                if (parameters === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "TreeItem -> notifications -> add: Не задан параметр - объект с настройками уведомления уведомления");
                    return false;
                }

                if (parameters.id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "TreeItem -> notifications -> add: Не задана настройка - идентификатор уведомления");
                    return false;
                }

                if (parameters.value === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "TreeItem -> notifications -> add: Не задана настройка - значение уведомления");
                    return false;
                }

                var notification = factory({ classes: ["TreeItemNotification"], base_class: "TreeItemNotification" });
                notification.id = parameters.id;
                notification.value = parameters.value;
                notification.icon = parameters.icon !== undefined ? parameters.icon : "";
                notification.class = parameters.class !== undefined ? parameters.class : "";
                notification.isVisible = parameters.isVisible;
                this.items.push(notification);

                return true;
            },

            getById: function (id) {
                if (id === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "TreeItem -> notifications -> getById: Не задан параметр - идентификатор уведомления");
                    return false;
                }

                var length = this.items.length;
                for (var i = 0; i < length; i++) {
                    if (this.items[i].id === id)
                        return this.items[i];
                }

                return false;
            }
        },
        onAddChildren: function (children, data) {},
        onDeleteChildren: function (children) {},
        onSelect: function (item) {}
    });
$classesInjector.add("TreeItemNotification", {
        id: "",
        value: 0,
        icon: "",
        class: "",
        isVisible: true
    });
$classesInjector
    .add("TreeStructure", {
        id: "",
        rootKey: 0,
        expandOnSelect: false,
        collapseOnDeselect: false,
        showNotifications: true,
        class: "",
        stack: {},
        initial: {},
        selectedItem: false,
        onAddItem: function (item) {}
    });

$classesInjector
    .add("Attachment", {
        _dependencies__: [],
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        violationId: new Field({ source: "VIOLATION_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        title: new Field({ source: "TITLE", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        type: new Field({ source: "MIME_TYPE", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        size: new Field({ source: "SIZE", type: DATA_TYPE_INTEGER, default_value: 0, value: 0, backupable: true, displayable: true }),
        url: new Field({ source: "URL", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        added: new Field({ source: "DATE_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        isInAddMode: false
    });

$classesInjector
    .add("Division", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        parentId: new Field({ source: "PARENT_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, bacupable: true }),
        sortId: new Field({ source: "SORT_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        shortTitle: new Field({ source: "TITLE_SHORT", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        fullTitle: new Field({ source: "TITLE_FULL", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        violationsAdded: new Field({ source: "VIOLATIONS_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        attachmentsAdded: new Field({ source: "ATTACHMENTS_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        storage: new Field({ source: "FILE_STORAGE_HOST", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        isDepartment: new Field({ source: "IS_DEPARTMENT", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        path: new Field({ source: "PATH", type: DATA_TYPE_STRING, value: "", default_value: "" })
    });

$classesInjector
    .add("ESKGroup", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        title: new Field({ source: "TITLE", type: DATA_TYPE_STRING, value: "", default_value: "" }),
        description: new Field({ source: "DESCRIPTION", type: DATA_TYPE_STRING, value: "", default_value: "" })
    });
$classesInjector
    .add("Violation", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        userId: new Field({ source: "USER_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        divisionId: new Field({ source: "DIVISION_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        eskGroupId: new Field({ source: "ESK_GROUP_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        eskObject: new Field({ source: "ESK_OBJECT", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        happened: new Field({ source: "DATE_HAPPENED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        ended: new Field({ source: "DATE_ENDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        added: new Field({ source: "DATE_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        description: new Field({ source: "DESCRIPTION", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        isConfirmed: new Field({ source: "IS_CONFIRMED", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        user: 0,
        attachments: [],
        isNew: false,
        newAttachments: 0
    });
$classesInjector
    .add("Weekday", {
        title: "",
        code: ""
    });

angular.module("violations", [])
    .run(["$log", "$divisions", "$violations", "$misc", "$session", "$users", "$navigation", "$settings", function ($log, $divisions, $violations, $misc, $session, $users, $navigation, $settings) {
        //$log.log("violations module run...");

        $session.init(window.initialData);
        $settings.init(window.initialData.settings);
        $users.users.init(window.initialData.users);
        $divisions.init(window.initialData.divisions);
        $violations.init();
        $misc.init(window.initialData);
        $violations.violations.getNew().userId.value = $session.getCurrentUser().id.value;
        $violations.violations.getNew().divisionId.value = $session.getCurrentUser().divisionId.value;
        //$violations.violations.startDate = new moment().unix();


        $navigation.add({
            id: "violations",
            url: "/",
            icon: "fa fa-bolt",
            title: "Нарушения",
            order: 1
        });

        $navigation.add({
            id: "users",
            url: "/users/",
            icon: "fa fa-user",
            title: "Пользователи",
            order: 3,
            isVisible: $session.getCurrentUser().isAdministrator.value === true ? true : false
        });

        $navigation.add({
            id: "user",
            parentId: "users",
            url: "/user/",
            icon: "fa fa-user",
            title: "",
            isVisible: false
        });

        $navigation.add({
            id: "divisions",
            url: "/divisions/",
            icon: "fa fa-building",
            title: "Стр. подразделения",
            order: 2,
            isVisible: $session.getCurrentUser().isAdministrator.value === true ? true : false
        });


        $navigation.add({
            id: "help",
            url: "/help/",
            icon: "fa fa-info",
            title: "Помощь",
            order: 4,
            isVisible: true
        });
        
    }]);
$classesInjector
    .add("Attachment", {
        _dependencies__: [],
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        violationId: new Field({ source: "VIOLATION_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        title: new Field({ source: "TITLE", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        type: new Field({ source: "MIME_TYPE", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        size: new Field({ source: "SIZE", type: DATA_TYPE_INTEGER, default_value: 0, value: 0, backupable: true, displayable: true }),
        url: new Field({ source: "URL", type: DATA_TYPE_STRING, default_value: "", value: "", backupable: true, displayable: true }),
        added: new Field({ source: "DATE_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        isInAddMode: false
    });

$classesInjector
    .add("Division", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        parentId: new Field({ source: "PARENT_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, bacupable: true }),
        sortId: new Field({ source: "SORT_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        shortTitle: new Field({ source: "TITLE_SHORT", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        fullTitle: new Field({ source: "TITLE_FULL", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        violationsAdded: new Field({ source: "VIOLATIONS_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        attachmentsAdded: new Field({ source: "ATTACHMENTS_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        storage: new Field({ source: "FILE_STORAGE_HOST", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        isDepartment: new Field({ source: "IS_DEPARTMENT", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        path: new Field({ source: "PATH", type: DATA_TYPE_STRING, value: "", default_value: "" })
    });

$classesInjector
    .add("ESKGroup", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        title: new Field({ source: "TITLE", type: DATA_TYPE_STRING, value: "", default_value: "" }),
        description: new Field({ source: "DESCRIPTION", type: DATA_TYPE_STRING, value: "", default_value: "" })
    });
$classesInjector
    .add("Violation", {
        id: new Field({ source: "ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        userId: new Field({ source: "USER_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        divisionId: new Field({ source: "DIVISION_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        eskGroupId: new Field({ source: "ESK_GROUP_ID", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        eskObject: new Field({ source: "ESK_OBJECT", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        happened: new Field({ source: "DATE_HAPPENED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        ended: new Field({ source: "DATE_ENDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0, backupable: true }),
        added: new Field({ source: "DATE_ADDED", type: DATA_TYPE_INTEGER, value: 0, default_value: 0 }),
        description: new Field({ source: "DESCRIPTION", type: DATA_TYPE_STRING, value: "", default_value: "", backupable: true }),
        isConfirmed: new Field({ source: "IS_CONFIRMED", type: DATA_TYPE_BOOLEAN, value: false, default_value: false, backupable: true }),
        user: 0,
        attachments: [],
        isNew: false,
        newAttachments: 0
    });
$classesInjector
    .add("Weekday", {
        title: "",
        code: ""
    });

angular
    .module("violations")
    .controller("DivisionsController", ["$log", "$scope", "$divisions", "$violations", "$tree", "$modals", function ($log, $scope, $divisions, $violations, $tree, $modals) {
        $scope.divisions = $divisions;
        $scope.violations = $violations;
        $scope.modals = $modals;
        $scope.errors = {
            fullTitle: undefined,
            shortTitle: undefined
        };


        $scope.openNewDivisionModal = function () {
            $modals.open("new-division-modal");
        };


        $scope.cancelAddDivision = function () {
            $divisions.getNew()._backup_.restore();
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }
        };


        $scope.add = function () {
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }

            if ($divisions.getNew().shortTitle.value === "")
                $scope.errors.shortTitle = "Вы не указали краткое наименование";

            if ($divisions.getNew().fullTitle.value === "")
                $scope.errors.fullTitle = "Вы не указали полное наименование";

            if ($scope.errors.fullTitle == undefined && $scope.errors.shortTitle === undefined) {
                $divisions.add(function (division) {
                    $modals.close();
                    $tree.addItem({
                        treeId: "divisions-tree",
                        key: division.id.value,
                        parentKey: division.parentId.value,
                        display: division.shortTitle.value
                    });
                });
            }
        };


        $scope.openEditDivisionModal = function () {
            $modals.open("edit-division-modal");
        };


        $scope.cancelEditDivision = function () {
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }
            $divisions.getCurrent()._backup_.restore();
            $divisions.getCurrent()._states_.changed(false);
        };


        $scope.save = function () {
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }

            if ($divisions.getCurrent().shortTitle.value === "")
                $scope.errors.shortTitle = "Вы не указали краткое наименование";

            if ($divisions.getCurrent().fullTitle.value === "")
                $scope.errors.fullTitle = "Вы не указали полное наименование";

            if ($scope.errors.fullTitle == undefined && $scope.errors.shortTitle === undefined) {
                $divisions.edit(function (division) {
                    $modals.close();
                    $tree.getItemByKey("divisions-tree", division.id.value).display = division.shortTitle.value;
                });
            }
        };


        if (!$tree.getById("divisions-tree")) {
            //$log.log("NO TREE");
            var divisionsTree = $tree.register({
                id: "divisions-tree",
                rootKey: 0,
                expandOnSelect: true,
                collapseOnDeselect: true,
                onSelect: function (division) {
                    if (division.isSelected === true) {
                        $divisions.select(division.key);
                        $log.log("current divivison  = ", $divisions.getCurrent());
                        $divisions.getNew().parentId.value = division.key;
                    } else
                        $divisions.getNew().parentId.value = 0;
                }
            });


            var length = $divisions.getAll().length;
            for (var i = 0; i < length; i++) {
                var division = $divisions.getAll()[i];
                var item = $tree.addItem({
                    treeId: "divisions-tree",
                    key: division.id.value,
                    parentKey: division.parentId.value,
                    display: division.shortTitle.value,
                    order: division.sortId.value
                });
                if (division.id.value === 1) {
                    item.isExpanded = true;
                }
            }
        }
    }]);

angular
    .module("violations")
    .controller("HeaderController", ["$log", "$scope", "$session", "$navigation", "$window", "$modals", "$misc", "$settings", function ($log, $scope, $session, $navigation, $window, $modals, $misc, $settings) {
        $scope.misc = $misc;
        $scope.session = $session;
        $scope.settings = $settings;
        $scope.navigation = $navigation;
        $scope.modals = $modals;


        $scope.openSettingsModal = function () {
            $modals.open("settings-modal");
        };


        $scope.closeSettingsModal = function () {
            $log.log("close modal");
            if ($settings.changed() === true) {
                for (var setting in $settings.getAll()) {
                    $settings.getAll()[setting]._backup_.restore();
                    $settings.getAll()[setting]._states_.changed(false);
                }
            }
            $settings.changed(false);
            $modals.close();
        };


        $scope.saveSettings = function () {
            $settings.save(function () {
                $settings.changed(false);
            });
        };


        $scope.logout = function () {
            $session.logout(function () {
                $window.location.reload(true);
            });
        };

    }]);
angular
    .module("violations")
    .controller("HelpController", ["$scope", "$session", function ($scope, $session) {
        $scope.session = $session;
    }]);

angular
    .module("violations")
    .controller("NewUserController", ["$log", "$scope", "$http", "$location", "$users", "$violations", "$divisions", "$modals", "$tree", function ($log, $scope, $http, $location, $users, $violations, $divisions, $modals, $tree) {
        $scope.users = $users;
        $scope.violations = $violations;
        $scope.divisions = $divisions;
        $scope.modals = $modals;
        $scope.errors = {
            surname: undefined,
            name: undefined,
            fname: undefined,
            divisionId: undefined,
            email: undefined,
            login: undefined,
            password: undefined
        };



        if (!$tree.getById("new-user-tree")) {
            var newUserTree = $tree.register({
                id: "new-user-tree",
                rootKey: 0,
                expandOnSelect: true,
                collapseOnDeselect: true
            });

            newUserTree.onSelect = function (item) {
                //$log.log("selected division = ", item);
                $scope.selectDivision(item);
            };


            var length = $divisions.getAll().length;
            for (var i = 0; i < length; i++) {
                var division = $divisions.getAll()[i];
                var item = $tree.addItem({
                    treeId: "new-user-tree",
                    key: division.id.value,
                    parentKey: division.parentId.value,
                    display: division.shortTitle.value,
                    order: division.sortId.value
                });
                if (division.id.value === 1) {
                    item.isExpanded = true;
                }
            }
        }



        $scope.selectDivision = function (division) {
            $users.users.getNew().divisionId.value = division.key;
        };



        $scope.openSelectDivisionModal = function () {
            $modals.open("new-user-division-modal");
        };


        $scope.cancel = function () {
            $location.url("/users");
            $users.users.getNew().divisionId.value = 0;
            $users.users.getNew().surname.value = "";
            $users.users.getNew().name.value = "";
            $users.users.getNew().fname.value = "";
            $users.users.getNew().email.value = "";
            $users.users.getNew().login.value = "";
            $users.users.getNew().password.value = "";
            $users.users.getNew().isAdministrator.value = false;
            $users.users.getNew().allowEdit.value = false;
            $users.users.getNew().allowConfirm.value = false;
        };


        $scope.add = function () {
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }

            if ($users.users.getNew().divisionId.value === 0)
                $scope.errors.divisionId = "Вы не выбрали структурное подразделение";
            if ($users.users.getNew().surname.value === "")
                $scope.errors.surname = "Вы не указали фамилию";
            if ($users.users.getNew().name.value === "")
                $scope.errors.name = "Вы не указали имя";
            if ($users.users.getNew().fname.value === "")
                $scope.errors.fname = "Вы не указали отчество";
            if ($users.users.getNew().email.value === "")
                $scope.errors.email = "Вы не указали e-mail";

            if ($users.users.getNew().isLDAPEnabled.value === true) {
                if ($users.users.getNew().login.value === "")
                    $scope.errors.login = "Вы не указали учетную запись Active Directory";
            } else {
                if ($users.users.getNew().password.value === "")
                    $scope.errors.password = "Вы не указали пароль";
            }

            if ($scope.errors.divisionId === undefined && $scope.errors.surname === undefined &&
                $scope.errors.name === undefined && $scope.errors.fname === undefined &&
                $scope.errors.email === undefined && $scope.errors.login === undefined && $scope.errors.password === undefined) {
                if ($users.users.getNew().isLDAPEnabled.value === true) {
                    if ($scope.errors.login === undefined)
                        $users.users.add(function () {
                            $location.url("/users");
                            $users.users.getNew()._backup_.restore();
                        });
                } else {
                    if ($scope.errors.password === undefined)
                        $users.users.add(function () {
                            $location.url("/users");
                            $users.users.getNew()._backup_.restore();
                        });
                }


                /*
                $users.users.add(function () {
                    $location.url("/users");
                    $users.users.getNew()._backup_.restore();
                });
                */
            }
        };

    }]);
"use strict";


(function () {
    angular
        .module("violations")
        .controller("NewViolationController", ["$log", "$scope", "$violations", "$divisions", "$misc", "$factory", "$tree", "$location", "$modals", "$session", "$dateTimePicker", function ($log, $scope, $violations, $divisions, $misc, $factory, $tree, $location, $modals, $session, $dateTimePicker) {
            $scope.violations = $violations;
            $scope.divisions = $divisions;
            $scope.misc = $misc;
            $scope.modals = $modals;
            $scope.submitted = false;
            $scope.isUploadInProgress = false;
            $scope.errors = {
                date: undefined,
                divisionId: undefined,
                eskGroupId: undefined,
                eskObject: undefined,
                description: undefined,
                ended: undefined
            };
            $scope.uploaderData = {
                serviceId: "violations",
                violationId: $violations.violations.getNew().id.value,
                divisionId: $violations.violations.getNew().divisionId.value
            };
            $scope.today = new moment().hours(23).minutes(59).seconds(59).unix();
            $scope.hours = 0;
            $scope.minutes = 0;
            $scope.endHours = 0;
            $scope.endMinutes = 0;
            $scope.uploaderLink = "test";



            $scope.openSelectDivisionModal = function () {
                $modals.open("new-violation-division-modal");
            };



            /**
             * Отмена добавления нового нарушения
             */
            $scope.cancel = function () {
                $location.url("/");
                var division = $divisions.getById($violations.violations.getNew().divisionId.value);
                var departmentId = $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value) !== undefined ? $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value).id.value : $session.getCurrentUser().divisionId.value;
                var url = division.storage.value !== "" ? division.storage.value + "/serverside/cancel.php" : "/serverside/cancel.php";

                if ($violations.violations.getNew().id.value !== 0) {
                    $violations.violations.cancel($violations.violations.getNew().id.value, url, departmentId, function () {
                        $violations.attachments.getNew().splice(0, $violations.attachments.getNew().length);
                    });
                }

                if ($divisions.getCurrent() !== undefined && $divisions.getCurrent().id.value === 1) {
                    $violations.violations.getNew().divisionId.value = 0;
                }
            };



            $scope.selectStartDate = function (date) {
                //$dateTimePicker.getById("new-violation-end-date").scope.settings.value = moment.unix(date).hours($scope.hours).minutes($scope.minutes).seconds(0).unix();
                $violations.violations.getNew()._states_.changed(true);
                $violations.violations.getNew().ended.value = $violations.violations.getNew().happened.value;
                $dateTimePicker.getById("new-violation-end-date").scope.settings.minDate = $violations.violations.getNew().happened.value;
            };


            $scope.onHoursChange = function () {
                var exp = new RegExp("^(0|[0-9]|[0-2][0-9])$");
                if (exp.test($scope.hours)) {
                    $violations.violations.getNew().happened.value = moment.unix($violations.violations.getNew().happened.value).hours($scope.hours).unix();
                } else {
                    $scope.hours = 0;
                    $violations.violations.getNew().happened.value = moment.unix($violations.violations.getNew().happened.value).hours($scope.hours).unix();
                }
                $violations.violations.getNew()._states_.changed(true);
            };



            $scope.onMinutesChange = function () {
                var exp = new RegExp("^(0|[0-9]|[0-5][0-9])$");
                if (exp.test($scope.minutes)) {
                    $violations.violations.getNew().happened.value = moment.unix($violations.violations.getNew().happened.value).minutes($scope.minutes).unix();
                } else {
                    $scope.minutes = 0;
                    $violations.violations.getNew().happened.value = moment.unix($violations.violations.getNew().happened.value).minutes($scope.minutes).unix();
                }
                $violations.violations.getNew()._states_.changed(true);
            };


            $scope.onEndHoursChange = function () {
                var exp = new RegExp("^(0|[0-9]|[0-2][0-9])$");
                if (exp.test($scope.endHours)) {
                    $violations.violations.getNew().ended.value = moment.unix($violations.violations.getNew().ended.value).hours($scope.endHours).unix();
                } else {
                    $scope.hours = 0;
                    $violations.violations.getNew().ended.value = moment.unix($violations.violations.getNew().ended.value).hours($scope.endHours).unix();
                }
                $violations.violations.getNew()._states_.changed(true);
            };



            $scope.onEndMinutesChange = function () {
                var exp = new RegExp("^(0|[0-9]|[0-5][0-9])$");
                if (exp.test($scope.endMinutes)) {
                    $violations.violations.getNew().ended.value = moment.unix($violations.violations.getNew().ended.value).minutes($scope.endMinutes).unix();
                } else {
                    $scope.endMinutes = 0;
                    $violations.violations.getNew().ended.value = moment.unix($violations.violations.getNew().ended.value).minutes($scope.endMinutes).unix();
                }
                $violations.violations.getNew()._states_.changed(true);
            };



            $scope.add = function () {
                for (var error in $scope.errors) {
                    $scope.errors[error] = undefined;
                }

                if ($violations.violations.getNew().ended.value < $violations.violations.getNew().happened.value)
                    $scope.errors.ended = "Дата устренения не может быть раньше времени ТН";
                if ($violations.violations.getNew().divisionId.value === 0)
                    $scope.errors.divisionId = "Вы не выбрали структурное подразделение";
                if ($violations.violations.getNew().eskGroupId.value === 0)
                    $scope.errors.eskGroupId = "Вы не выбрали группу ЭСК";
                if ($violations.violations.getNew().eskObject.value === "")
                    $scope.errors.eskObject = "Вы не указали объект ЭСК";
                if ($violations.violations.getNew().description.value === "")
                    $scope.errors.description = "Вы не указали описание";

                if ($scope.errors.date === undefined & $scope.errors.divisionId === undefined &&
                    $scope.errors.eskGroupId === undefined && $scope.errors.eskObject === undefined &&
                    $scope.errors.description === undefined && $scope.errors.ended === undefined) {
                    $violations.violations.add(function (violation) {
                        $violations.violations.setStart(0);
                        $violations.violations.getByDivisionId(violation.divisionId.value, function () {
                            $location.url("/");
                        });

                        $violations.violations.getNew().id.value = 0;
                        $violations.violations.getNew().happened.value = new moment().unix();
                        $violations.violations.getNew().eskGroupId.value = 0;
                        $violations.violations.getNew().eskObject.value = "";
                        $violations.violations.getNew().description.value = "";
                        $violations.attachments.getNew().splice(0, $violations.attachments.getNew().length);

                        var item = $tree.getItemByKey("session-divisions-tree", violation.divisionId.value);
                        item.data.violationsAdded++;
                        item.data.violationsTotal++;
                        item.notifications.getById("violations").value += 1;
                        item.notifications.getById("violations").isVisible = item.notifications.getById("violations").value > 0 ? true : false;
                        var att = violation.attachments.length;
                        item.notifications.getById("attachments").value += att;
                        item.notifications.getById("attachments").isVisible = item.notifications.getById("attachments").value > 0 ? true : false;
                        item.data.attachmentsTotal += att;
                        item.data.attachmentsAdded += att;

                        var length = violation.attachments.length;
                        for (var i = 0; i < length; i++) {
                            if (violation.attachments[i].isInAddMode === true)
                                violation.attachments[i].isInAddMode = false;
                        }

                        var parent = $tree.getItemByKey("global-divisions-tree", item.parentKey);
                        while (parent) {
                            //$log.log("parent found = ", parent);
                            parent.data.violationsTotal++;
                            parent.notifications.getById("violations").value += 1;
                            parent.notifications.getById("violations").isVisible = parent.notifications.getById("violations").value > 0 ? true : false;
                            parent.data.attachmentsTotal += att;
                            parent.notifications.getById("attachments").value += att;
                            parent.notifications.getById("attachments").isVisible = parent.notifications.getById("attachments").value > 0 ? true : false;
                            parent = $tree.getItemByKey("global-divisions-tree", parent.parentKey);
                        }
                        $tree.getById("global-divisions-tree").calcRoot();
                    });
                }
            };



            $scope.onBeforeUploadAttachment = function () {
                //$log.info("uploader onBeforeUpload");

                $scope.isUploadInProgress = true;
                $scope.uploaderData.violationId = $violations.violations.getNew().id.value;

                //var division = $divisions.getById($session.getCurrentUser().divisionId.value);
                var division = $divisions.getById($violations.violations.getNew().divisionId.value);
                //$log.log("current division = ", division);
                if (division.storage.value === "") {
                    $scope.uploaderLink = "/serverside/uploader.php";
                    //$log.log("departments = ", $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value));
                    $scope.uploaderData.departmentId = $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value) !== undefined ? $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value).id.value : $session.getCurrentUser().divisionId.value;
                } else
                    $scope.uploaderLink = division.storage.value + "/upload/share";
                //$log.log("uploaderlink = ", $scope.uploaderLink);
                //$log.log("currentUserDivision = ", division);
                //$log.log("currentUserDepartment = ", $scope.uploaderData.departmentId);
            };



            $scope.onCompleteUploadAttachment = function (data) {
                //$log.log("upload complete", data);
                var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                attachment._model_.fromJSON(data);
                attachment.isInAddMode = true;
                $violations.violations.addAttachmentToNew(attachment);
                $violations.attachments.add(attachment);
                $scope.isUploadInProgress = false;
                delete $scope.uploaderData.storage;

                //$log.log("attachment = ", attachment);

                if (attachment.violationId.value !== 0)
                    $violations.violations.getNew().id.value = attachment.violationId.value;
            };



            $scope.deleteAttachment = function (attachmentId) {
                if (attachmentId !== undefined) {
                    var division = $divisions.getById($violations.violations.getNew().divisionId.value);
                    var departmentId = $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value) !== undefined ? $divisions.getDepartmentByDivisionId($violations.violations.getNew().divisionId.value).id.value : $violations.violations.getNew().divisionId.value;
                    var url = division.storage.value !== "" ? division.storage.value + "/serverside/deleteAttachment.php" : "/serverside/deleteAttachment.php";

                    $violations.attachments.delete(attachmentId, departmentId, url, function () {
                        var length = $violations.attachments.getNew().length;
                        for (var i = 0; i < length; i++) {
                            if ($violations.attachments.getNew()[i].id.value === attachmentId) {
                                $violations.attachments.getNew().splice(i, 1);
                                break;
                            }
                        }
                    });
                }
            };




        }]);
})();
angular
    .module("violations")
    .controller("UserController", ["$log", "$scope", "$location", "$users", "$violations", "$divisions", "$tree", "$modals", function ($log, $scope, $location, $users, $violations, $divisions, $tree, $modals) {
        $scope.users = $users;
        $scope.violations = $violations;
        $scope.divisions = $divisions;
        $scope.modals = $modals;
        $scope.errors = {
            divisionId: undefined,
            surname: undefined,
            name: undefined,
            fname: undefined,
            email: undefined,
            login: undefined,
            password: undefined
        };



        $scope.openSelectDivisionModal = function () {
            $modals.open("current-user-division-modal");
        };



        $scope.selectDivision = function (division) {
            $users.users.getCurrent().divisionId.value = division.key;
            $users.users.getCurrent()._states_.changed(true);
        };



        if (!$tree.getById("current-user-tree")) {
            var currentUserTree = $tree.register({
                id: "current-user-tree",
                rootKey: 0,
                expandOnSelect: true,
                collapseOnDeselect: true
            });

            currentUserTree.onSelect = function (item) {
                //$log.log("selected division = ", item);
                $scope.selectDivision(item);
            };


            var length = $divisions.getAll().length;
            for (var i = 0; i < length; i++) {
                var division = $divisions.getAll()[i];
                var item = $tree.addItem({
                    treeId: "current-user-tree",
                    key: division.id.value,
                    parentKey: division.parentId.value,
                    display: division.shortTitle.value,
                    order: division.sortId.value
                });
                if (division.id.value === 1) {
                    item.isExpanded = true;
                }
            }
        }



        $scope.gotoUsers = function () {
            $location.url("/users");
            $users.users.getCurrent()._backup_.restore();
            $users.users.getCurrent()._states_.changed(false);
        };



        $scope.save = function () {
            for (var index in $scope.errors) {
                $scope.errors[index] = undefined;
            }

            if ($users.users.getCurrent().divisionId.value === 0)
                $scope.errors = "Вы не выбрали струтурное подразделение";
            if ($users.users.getCurrent().surname.value === "")
                $scope.errors.surname = "Вы не указали фамилию";
            if ($users.users.getCurrent().name.value === "")
                $scope.errors.name = "Вы не указали имя";
            if ($users.users.getCurrent().fname.value === "")
                $scope.errors.fname = "Вы не указали отчество";
            if ($users.users.getCurrent().email.value === "")
                $scope.errors.email = "Вы не указали e-mail";
            if ($users.users.getCurrent().isLDAPEnabled.value === true) {
                if ($users.users.getCurrent().login.value === "")
                    $scope.errors.login = "Вы не указали учетную запись Active Directory";
            } else {
                if ($users.users.getCurrent().password.value === "")
                    $scope.errors.password = "Вы не указали пароль";
            }

            if ($scope.errors.divisionId === undefined && $scope.errors.surname === undefined &&
                $scope.errors.name === undefined && $scope.errors.fname === undefined &&
                $scope.errors.email === undefined && $scope.errors.login === undefined && $scope.errors.password === undefined) {

                if ($users.users.getCurrent().isLDAPEnabled.value === true) {
                    if ($scope.errors.login === undefined)
                        $users.users.edit(function() {});
                } else {
                    if ($scope.errors.password === undefined)
                        $users.users.edit(function() {});
                }

            }
        };
    }]);
angular
    .module("violations")
    .controller("UsersController", ["$log", "$scope", "$location", "$users", "$violations", "$divisions", function ($log, $scope, $location, $users, $violations, $divisions) {
        $scope.users = $users;
        $scope.violations = $violations;
        $scope.divisions = $divisions;


        $scope.gotoNewUser = function () {
            $location.url("/new-user");
        };


        $scope.selectUser = function (user) {
            $users.users.select(user.id.value, function () {
                $location.url("/user/" + user.id.value);
            });
        };
    }]);
angular
    .module("violations")
    .controller("ViolationController", ["$log", "$scope", "$routeParams", "$location", "$violations", "$divisions", "$misc", "$factory", "$tree", "$session", function ($log, $scope, $routeParams, $location, $violations, $divisions, $misc, $factory, $tree, $session) {
        $scope.violations = $violations;
        $scope.divisions = $divisions;
        $scope.misc = $misc;
        $scope.session = $session;
        $scope.violation = undefined;
        $scope.uploaderData = {
            serviceId: "violations",
            violationId: 0,
            divisionId: 0
        };
        $scope.errors = {

            eskGroupId: undefined,
            eskObject: undefined,
            description: undefined
        };
        $scope.isUploadInProgress = false;
        $scope.uploaderLink = "test";
        $scope.endHours = moment.unix($violations.violations.getCurrent().ended.value).hours();
        $scope.endMinutes = moment.unix($violations.violations.getCurrent().ended.value).minutes();



        /**
         * Возврат в на главный экран к списку ТН
         */
        $scope.gotoMain = function () {
            $location.url("/");

            /*** Отменяем возможность удаления добавленных файлов в выбранном ТН ***/
            var length = $violations.violations.getCurrent().attachments.length;
            for (var i = 0; i < length; i++) {
                if ($violations.violations.getCurrent().attachments[i].isInAddMode === true)
                    $violations.violations.getCurrent().attachments[i].isInAddMode = false;
            }

            /*** Если ТН было изменено - отменяем изменения ***/
            if ($violations.violations.getCurrent()._states_.changed() === true) {
                $violations.violations.getCurrent()._backup_.restore();
                $violations.violations.getCurrent()._states_.changed(false);
            }
            $violations.violations.select(parseInt($routeParams.violationId));
        };



        $scope.onBeforeUploadAttachment = function () {
            $scope.uploaderData.divisionId = $violations.violations.getCurrent().divisionId.value;
            $violations.violations.getCurrent().isInAddAttachmentMode = true;
            $scope.isUploadInProgress = true;
            $scope.uploaderData.violationId = $violations.violations.getCurrent().id.value;

            //var division = $divisions.getById($session.getCurrentUser().divisionId.value);
            var division = $divisions.getById($violations.violations.getCurrent().divisionId.value);
            //$log.log("current division = ", division);
            if (division.storage.value === "") {
                $scope.uploaderLink = "/serverside/uploader.php";
                $scope.uploaderData.departmentId = $divisions.getDepartmentByDivisionId($violations.violations.getCurrent().divisionId.value) !== undefined ? $divisions.getDepartmentByDivisionId($violations.violations.getCurrent().divisionId.value).id.value : $session.getCurrentUser().divisionId.value;
            } else
                $scope.uploaderLink = division.storage.value + "/upload/share";
        };



        $scope.onCompleteUploadAttachment = function (data) {
            var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
            attachment._model_.fromJSON(data);
            attachment.isInAddMode = true;
            $violations.violations.getCurrent().attachments.push(attachment);
            $violations.violations.getCurrent().newAttachments++;
            $violations.violations.addAttachment();
            $scope.isUploadInProgress = false;

            var tree = $tree.getById("global-divisions-tree");
            if (tree) {
                var item = $tree.getItemByKey("global-divisions-tree", $violations.violations.getCurrent().divisionId.value);
                item.data.attachmentsAdded++;
                item.data.attachmentsTotal++;
                item.notifications.getById("attachments").value += 1;
                item.notifications.getById("attachments").isVisible = item.notifications.getById("attachments").value > 0 ? true : false;

                var prev = item;
                var parent = $tree.getItemByKey("global-divisions-tree", item.parentKey);
                while (parent) {
                    parent.data.attachmentsTotal += 1;
                    parent.notifications.getById("attachments").value += 1;
                    parent.notifications.getById("attachments").isVisible = parent.notifications.getById("attachments").value > 0 ? true : false;
                    prev = parent;
                    parent = $tree.getItemByKey("global-divisions-tree", parent.parentKey);
                }

                tree.calcRoot();
            }
        };



        $scope.deleteAttachment = function (attachmentId) {
            if (attachmentId !== undefined) {
                var division = $divisions.getById($violations.violations.getCurrent().divisionId.value);
                var departmentId = $divisions.getDepartmentByDivisionId($violations.violations.getCurrent().divisionId.value) !== undefined ? $divisions.getDepartmentByDivisionId($violations.violations.getCurrent().divisionId.value).id.value : $violations.violations.getCurrent().divisionId.value;
                var url = division.storage.value !== "" ? division.storage.value + "/serverside/deleteAttachment.php" : "/serverside/deleteAttachment.php";

                $violations.attachments.delete(attachmentId, departmentId, url, function () {
                    var length = $violations.violations.getCurrent().attachments.length;
                    for (var i = 0; i < length; i++) {
                        if ($violations.violations.getCurrent().attachments[i].id.value === attachmentId) {
                            $violations.violations.getCurrent().attachments.splice(i, 1);
                            break;
                        }
                    }
                });
            }
        };



        $scope.save = function () {
            for (var error in $scope.errors) {
                $scope.errors[error] = undefined;
            }

            if ($violations.violations.getCurrent().ended.value < $violations.violations.getCurrent().happened.value)
                $scope.errors.ended = "Дата устренения не может быть раньше времени ТН";
            if ($violations.violations.getCurrent().eskGroupId.value === 0)
                $scope.errors.eskGroupId = "Вы не выбрали группу ЭСК";
            if ($violations.violations.getCurrent().eskObject.value === "")
                $scope.errors.eskObject = "Вы не указали объект ЭСК";
            if ($violations.violations.getCurrent().description.value === "")
                $scope.errors.description = "Вы не указали описание";

            if ($scope.errors.eskGroupId === undefined && $scope.errors.eskObject === undefined && $scope.errors.description === undefined && $scope.errors.ended === undefined) {
                $scope.inProgress = true;
                $violations.violations.edit(function () {
                    $scope.inProgress = false;
                    $violations.violations.getCurrent()._states_.changed(false);
                    $violations.violations.getCurrent()._backup_.setup();
                });
            }

        };


        $scope.selectEndDate = function () {
            $violations.violations.getCurrent()._states_.changed(true);
        };


        $scope.onEndHoursChange = function () {
            $violations.violations.getCurrent()._states_.changed(true);
            var exp = new RegExp("^(0|[0-9]|[0-2][0-9])$");
            if (exp.test($scope.endHours)) {
                $violations.violations.getCurrent().ended.value = moment.unix($violations.violations.getCurrent().ended.value).hours($scope.endHours).unix();
            } else {
                $scope.endHours = 0;
                $violations.violations.getCurrent().ended.value = moment.unix($violations.violations.getCurrent().ended.value).hours($scope.endHours).unix();
            }
        };



        $scope.onEndMinutesChange = function () {
            $violations.violations.getCurrent()._states_.changed(true);
            var exp = new RegExp("^(0|[0-9]|[0-5][0-9])$");
            if (exp.test($scope.endMinutes)) {
                $violations.violations.getCurrent().ended.value = moment.unix($violations.violations.getCurrent().ended.value).minutes($scope.endMinutes).unix();
            } else {
                $scope.endMinutes = 0;
                $violations.violations.getCurrent().ended.value = moment.unix($violations.violations.getCurrent().ended.value).minutes($scope.endMinutes).unix();
            }
        };
    }]);
angular
    .module("violations")
    .controller("ViolationsController", ["$log", "$scope", "$violations", "$misc", "$vFilters", "$location", "$tree", "$session", "$dateTimePicker", function ($log, $scope, $violations, $misc, $vFilters, $location, $tree, $session, $dateTimePicker) {
        $scope.violations = $violations;
        $scope.misc = $misc;
        $scope.filters = $vFilters;
        $scope.today = new moment().hours(23).minutes(59).seconds(59).unix();

        $scope.selectStartDate = function (value) {
            $log.log("onSelect called", value);
            //$violations.violations.filter.setStartDate(value);
            $violations.violations.setStart(0);
            $dateTimePicker.getById("violations-end-date").scope.settings.minDate = $violations.violations.filter.startDate;
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };


        /*
        $scope.clearStartDate = function () {
            $violations.violations.filter.startDate = 0;
            $violations.violations.setStart(0);
            $dateTimePicker.getById("violations-end-date").scope.settings.minDate = 0;
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };
        */


        $scope.cancelStartDate = function () {
            $violations.violations.filter.cancelStartDate(function () {
                $violations.violations.setStart(0);
                $dateTimePicker.getById("violations-end-date").scope.settings.minDate = 0;
                var division = $tree.getById("session-divisions-tree").selectedItem;
                if (division !== undefined)
                    $violations.violations.getByDivisionId(division.key);
            });
        };


        $scope.selectEndDate = function () {
            $violations.violations.setStart(0);
            $violations.violations.endDate = moment.unix($violations.violations.filter.endDate).hours(23).minutes(59).seconds(59).unix();
            $dateTimePicker.getById("violations-start-date").scope.settings.maxDate = $violations.violations.filter.endDate;
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };

        /*
        $scope.clearEndDate = function () {
            $violations.violations.filter.endDate = 0;
            $violations.violations.setStart(0);
            //$dateTimePicker.getAll()[0].scope.settings.maxDate = $scope.today;
            $dateTimePicker.getById("violations-start-date").scope.settings.maxDate = $scope.today;
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };
        */

        $scope.cancelEndDate = function () {
            $violations.violations.filter.cancelEndDate(function () {
                $violations.violations.setStart(0);
                $dateTimePicker.getById("violations-start-date").scope.settings.maxDate = $scope.today;
                var division = $tree.getById("session-divisions-tree").selectedItem;
                if (division !== undefined)
                    $violations.violations.getByDivisionId(division.key);
            });
        };


        $scope.cancelBothDates = function () {
            $violations.violations.setStart(0);
            $violations.violations.filter.cancelStartDate();
            $dateTimePicker.getById("violations-start-date").scope.settings.maxDate = $scope.today;
            $violations.violations.filter.cancelEndDate();
            $dateTimePicker.getById("violations-end-date").scope.settings.minDate = 0;
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };


        $scope.gotoNewViolation = function () {
            $location.url("/new");
        };


        $scope.selectDivision = function (division) {
            $violations.violations.setStart(0);
            if (division.isSelected === true) {
                $violations.violations.getNew().divisionId.value = division.key;
                $violations.violations.getByDivisionId(division.key);
                //$log.log("new = ", $violations.violations.getNew());

            }
        };


        $scope.selectViolation = function (violationId) {
            if (violationId !== undefined) {
                $violations.violations.select(violationId, function () {
                    $location.url("/violations/" + violationId);
                });
            }
        };


        $scope.clearViolationId = function () {};

        $scope.onChangeViolationId = function () {
            $log.log("violationId changed");
            var violationId = $violations.violations.filter.violationId;
            if (violationId !== "") {
                if (isNaN(violationId))
                    $violations.violations.filter.violationId = "";
                else
                    $violations.violations.filter.violationId = Math.floor(violationId);
            }
        };


        $scope.searchViolationById = function () {
            $log.log("search pressed");
            $violations.violations.filter.isIdSent(true);
        };


        $scope.selectEskGroup = function () {
            var division = $tree.getById("session-divisions-tree").selectedItem;
            if (division !== undefined)
                $violations.violations.getByDivisionId(division.key);
        };

    }]);

angular
    .module("violations")
    .filter("byViolationId", ["$log", function ($log) {
        return function (input, violationId) {
            if (violationId !== undefined && violationId !== 0) {
                var length = input.length;
                var result = [];
                
                for (var i = 0; i < length; i++) {
                    if (input[i].violationId.value === violationId)
                        result.push(input[i]);
                }
                return result;
            } else
                return input;

        }
    }]);
angular.module("violations")
    .filter("dateFilter", ["$log", function ($log) {
        return function (input) {
            return moment.unix(input).format("DD MMMM YYYY, HH:mm");
        }
    }]);
angular.module("violations")
    .filter("dateShort", ["$log", function ($log) {
        return function (input) {
            return moment.unix(input).format("DD.MM.YYYY");
        }
    }]);
angular.module("violations")
    .filter("day", ["$log", function ($log) {
        return function (input) {
            return moment.unix(input).format("DD MMMM YYYY");
        }
    }]);

angular
    .module("violations")
    .filter("filesize", [function () {
        return function (input, precision) {
            if (typeof precision === 'undefined') precision = 1;
            var units = ['байт', 'кб', 'мб', 'гб', 'тв', 'пб'];
            var number = Math.floor(Math.log(input) / Math.log(1024));
            return (input / Math.pow(1024, Math.floor(number))).toFixed(precision) +  ' ' + units[number];
        }
    }]);

angular.module("violations")
    .filter("time", ["$log", function ($log) {
        return function (input) {
            return moment.unix(input).format("HH:mm");
        }
    }]);
angular
    .module("violations")
    .filter('toArray', [function () {
        return function (input) {
            var result = [];
            for (var index in input) {
                result.push(input[index]);
            }
            return result;
        }
    }]);

angular
    .module("violations")
    .factory("$divisions", ["$log", "$http", "$factory", "$errors", "$session", "$violations", "$tree", function ($log, $http, $factory, $errors, $session, $violations, $tree) {
        var divisions = [];
        var currentDivision = undefined;
        var newDivision = $factory({ classes: ["Division",  "Model", "Backup", "States"], base_class: "Division" });
        newDivision._backup_.setup();

        return {


            /**
             * Выполняет инициализацию сервиса
             * @param source {object} - источник данных
             * @returns {boolean}
             */
            init: function (source) {
                if (source === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$divisions -> init: Не задан параметр - источник данных");
                    return false;
                }

                var tree = $tree.register({
                    id: "global-divisions-tree",
                    rootKey: 0,
                    expandOnSelect: true,
                    collapseOnDeselect: true
                });


                tree.calcRoot = function () {
                    var root = $tree.getItemByKey(tree.id, 1);
                    root.data.violationsTotal = root.data.violationsAdded;
                    root.notifications.getById("violations").value = root.data.violationsAdded;
                    root.data.attachmentsTotal = root.data.attachmentsAdded;
                    root.notifications.getById("attachments").value = root.data.attachmentsAdded;
                    for (var index in root.children) {
                        var child = root.children[index];
                        root.data.violationsTotal += child.data.violationsTotal;
                        root.notifications.getById("violations").value += child.data.violationsTotal;
                        root.data.attachmentsTotal += child.data.attachmentsTotal;
                        root.notifications.getById("attachments").value += child.data.attachmentsTotal;
                    }
                    root.notifications.getById("violations").isVisible = root.notifications.getById("violations").value > 0 ? true : false;
                    root.notifications.getById("attachments").isVisible = root.notifications.getById("attachments").value > 0 ? true : false;
                };


                tree.onAddItem = function (itm) {
                    itm.data.violationsTotal = itm.data.violationsAdded;
                    itm.data.attachmentsTotal = itm.data.attachmentsAdded;

                    itm.notifications.add({
                        id: "violations",
                        icon: "fa-bolt",
                        class: "violation-notification",
                        value: 0,
                        isVisible: true
                    });
                    itm.notifications.getById("violations").value = itm.data.violationsAdded;

                    itm.notifications.add({
                        id: "attachments",
                        icon: "fa-file",
                        class: "attachment-notification",
                        value: 0,
                        isVisible: true
                    });
                    itm.notifications.getById("attachments").value = itm.data.attachmentsAdded;

                    var prev = itm;
                    var parent = $tree.getItemByKey("global-divisions-tree", itm.parentKey);
                    while (parent) {
                        if (itm.data.violationsAdded > 0) {
                            parent.data.violationsTotal += itm.data.violationsAdded;
                            parent.notifications.getById("violations").value += itm.data.violationsAdded;
                            parent.notifications.getById("violations").isVisible = parent.notifications.getById("violations").value > 0 ? true : false;
                        }
                        if (itm.data.attachmentsAdded > 0) {
                            parent.data.attachmentsTotal += itm.data.attachmentsAdded;
                            parent.notifications.getById("attachments").value += itm.data.attachmentsAdded;
                            parent.notifications.getById("attachments").isVisible = parent.notifications.getById("attachments").value > 0 ? true : false;
                        }
                        prev = parent;
                        parent = $tree.getItemByKey("global-divisions-tree", parent.parentKey);
                    }
                };

                var length = source.length;
                for (var i = 0; i < length; i++) {
                    var division = $factory({ classes: ["Division", "Model", "Backup", "States"], base_class: "Division" });
                    division._model_.fromJSON(source[i]);
                    division._backup_.setup();
                    divisions.push(division);

                    var item = $tree.addItem({
                        treeId: "global-divisions-tree",
                        key: division.id.value,
                        parentKey: division.parentId.value,
                        display: division.shortTitle.value,
                        order: division.sortId.value,
                        data: {
                            violationsAdded: division.violationsAdded.value,
                            violationsTotal: 0,
                            attachmentsAdded: division.attachmentsAdded.value,
                            attachmentsTotal: 0
                        }
                    });

                    item.notifications.getById("violations").value = item.data.violationsTotal;
                    item.notifications.getById("violations").isVisible = item.notifications.getById("violations").value > 0 ? true : false;
                    item.notifications.getById("attachments").value = item.data.attachmentsTotal;
                    item.notifications.getById("attachments").isVisible = item.notifications.getById("attachments").value > 0 ? true : false;
                }
                tree.calcRoot();

                var sessionDivisionsTree = $tree.register({
                    id: "session-divisions-tree",
                    rootKey: 0,
                    class: "stacked",
                    expandOnSelect: true,
                    collapseOnDeselect: true,
                    onSelect: function (item) {}
                });
                sessionDivisionsTree.calcRoot = tree.calcRoot();

                var sessionDivisionRoot = $tree.getItemByKey("global-divisions-tree", $session.getCurrentUser().divisionId.value);
                if (sessionDivisionRoot) {
                    sessionDivisionsTree.initial[sessionDivisionRoot.key] = sessionDivisionRoot;
                    sessionDivisionsTree.stack = tree.stack;
                    $tree.selectItem("session-divisions-tree", sessionDivisionRoot.key);
                    //$tree.expandItem("session-divisions-tree", sessionDivisionRoot.key);
                }

                sessionDivisionsTree.onSelect = function (item) {
                    //$log.log("selected item = ", item);
                    $violations.violations.setStart(0);
                    if (item.isSelected === true) {
                        $violations.violations.getNew().divisionId.value = item.key;
                        $violations.violations.getByDivisionId(item.key);
                        //$log.log("new = ", $violations.violations.getNew());

                        var length = divisions.length;
                        var found = false;
                        for (var i = 0; i < length; i++) {
                            if (divisions[i].id.value === item.key) {
                                found = true;
                                if (divisions[i]._states_.selected() === false) {
                                    divisions[i]._states_.selected(true);
                                    currentDivision = divisions[i];
                                } else {
                                    divisions[i]._states_.selected(false);
                                    currentDivision = undefined;
                                }
                            }
                        }

                    }
                };



                var newViolationTree = $tree.register({
                    id: "new-violation-tree",
                    rootKey: 0,
                    class: "stacked",
                    expandOnSelect: true,
                    collapseOnDeselect: true,
                    showNotifications: false,
                    onSelect: function (item) {
                        //var division = this.getById(item.key);
                        //$log.log("div = ", division);
                        $violations.violations.getNew().divisionId.value = item.key;
                        //$log.log("div id = ", item.key);
                    }

                });
                var newViolationRoot = $tree.getItemByKey("global-divisions-tree", $session.getCurrentUser().divisionId.value);
                if (newViolationRoot) {
                    newViolationTree.initial[newViolationRoot.key] = newViolationRoot;
                    newViolationTree.stack = tree.stack;
                }
                $tree.expandItem("new-violation-tree", newViolationRoot.key);

                return true;
            },



            /**
             * Возвращает массив со свеми структурными подразделениями
             * @returns {Array}
             */
            getAll: function () {
                return divisions;
            },



            /**
             * Возвращает текущее структурное подразделение
             * @returns {undefined}
             */
            getCurrent: function () {
                return currentDivision;
            },



            /**
             * Возвращает новое структурное подразделение
             * @returns {*}
             */
            getNew: function () {
                return newDivision;
            },



            /**
             * Возвращает структурное подразделение по идентификатору
             * @param divisionId {integer} - идентификатор структурного подразделения
             * @returns {*}
             */
            getById: function (divisionId) {
                if (divisionId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$divisions -> getById: Не задан параметр - идентификатор структурного подразделения");
                    return false;
                }

                var length = divisions.length;
                for (var i = 0; i < length; i++) {
                    if (divisions[i].id.value === divisionId) {
                        return divisions[i];
                    }
                }
                return false;
            },



            /**
             * Выбирает структурное подразделение
             * @param divisionId {integer} - Идентификатор структурного подразделения
             * @param callback {function} - callback-функция
             * @returns {boolean}
             */
            select: function (divisionId, callback) {
                if (divisionId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$divisions -> select: Не задан параметр - идентификатор структурного подразделения");
                    return false;
                }

                var length = divisions.length;
                var found = false;
                for (var i = 0; i < length; i++) {
                    if (divisions[i].id.value === divisionId) {
                        found = true;
                        if (divisions[i]._states_.selected() === false) {
                            divisions[i]._states_.selected(true);
                            currentDivision = divisions[i];
                            if (callback !== undefined && typeof callback === "function")
                                callback(currentDivision);
                        } else {
                            divisions[i]._states_.selected(false);
                            currentDivision = undefined;
                        }
                    }
                }
                return found;
            },



            /**
             * Добавляет структурное подразделение
             * @param success {function} - callback-функция в случае успешного завершения
             * @param error {function} - callback-функция в случае ошибки
             */
            add: function (success, error) {
                var params = {
                    action: "addDivision",
                    data: {
                        parentId: newDivision.parentId.value,
                        shortTitle: newDivision.shortTitle.value,
                        fullTitle: newDivision.fullTitle.value,
                        storage: newDivision.storage.value,
                        isDepartment: newDivision.isDepartment.value === true ? 1 : 0
                    }
                };

                newDivision._states_.loading(true);
                $http.post("/serverside/api.php", params)
                    .success(function (data) {
                        newDivision._states_.loading(false);
                        if (data !== undefined) {
                            var division = $factory({ classes: ["Division", "Model", "Backup", "States"], base_class: "Division" });
                            division._model_.fromJSON(data);
                            division._backup_.setup();
                            divisions.push(division);
                            if (success !== undefined && typeof success === "function")
                                success(division);
                            return true;
                        }
                    })
                    .error(function () {
                        $errors.add(ERROR_TYPE_ENGINE, "$divisions -> add: Не удалось добавить структурное подразделение");
                        newDivision._states_.loading(false);
                        if (error !== undefined && typeof error === "function")
                            error();
                        return false;
                    });
            },



            /**
             * Сохраняет изменения в текущем структурном подразделении
             * @param success {function} - callback-функция в случае успешного завершения
             * @param error {function} - callback-функция в случае ошибки
             */
            edit: function (success, error) {
                if (currentDivision === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$divisions -> edit: Не выбрано текущее структурное подразделение");
                    return false;
                }

                var params = {
                    action: "editDivision",
                    data: {
                        id: currentDivision.id.value,
                        parentId: currentDivision.parentId.value,
                        shortTitle: currentDivision.shortTitle.value,
                        fullTitle: currentDivision.fullTitle.value,
                        storage: currentDivision.storage.value,
                        departmentId: this.getDepartmentByDivisionId(currentDivision.id.value).id.value,
                        isDepartment: currentDivision.isDepartment.value === true ? 1 : 0
                    }
                };

                currentDivision._states_.loading(true);
                $http.post("/serverside/api.php", params)
                    .success(function (data) {
                        currentDivision._states_.loading(false);
                        if (data !== undefined) {
                            currentDivision._backup_.setup();
                            if (success !== undefined && typeof success === "function")
                                success(currentDivision);
                            return true;
                        }
                    })
                    .error(function () {
                        $errors.add(ERROR_TYPE_ENGINE, "$divisions -> edit: Не удалось сохранить изменения в структурном подразделнии");
                        currentDivision._states_.loading(false);
                        if (error !== undefined && typeof error === "function")
                            error();
                        return false;
                    });
            },


            getDepartmentByDivisionId: function (divisionId) {
                if (divisionId === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$divisions -> getDepartmentByDivisionId: Не задан параметр - идентификатор структурного подразделения");
                    return false;
                }

                var length = divisions.length;
                for (var i = 0; i < length; i++) {
                    if (divisions[i].id.value === divisionId) {
                        var division = divisions[i];
                        while (division.isDepartment.value === false) {
                            var length2 = divisions.length;
                            for (var x = 0; x < length2; x++) {
                                if (divisions[x].id.value === division.parentId.value)
                                    division = divisions[x];
                            }
                        }
                        return division;
                    }
                }
            }
        }
    }]);
angular
    .module("violations")
    .factory("$vFilters", ["$log", "$errors", "$violations", function ($log, $errors, $violations) {
        var isEnabled = false;
        var isFilterByNumberActive = true;
        var isFilterByDateActive = false;
        var isFilterByEskGroupActive = false;
        var startDate = 0;
        var endDate = 0;
        var filters = [];

        return {
            violationNumber: "",
            startDate: 0,
            endDate: 0,
            eskGroupId: 0,


            enabled: function (flag) {
                //if (flag !== undefined && typeof flag !== "boolean") {
                //    $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$filters -> Неверно задан тип параметра");
                //    return false;
                //} else
                if (flag !== undefined)
                    isEnabled = flag;
                return isEnabled;
            },

            getActive: function () {
                return filters;
            },

            add: function () {},


            filterByNumber: function (flag) {
                if (flag !== undefined) {
                    isFilterByNumberActive = flag;
                    isFilterByDateActive = false;
                    isFilterByEskGroupActive = false;
                }
                return isFilterByNumberActive;
            },

            filterByDate: function (flag) {
                if (flag !== undefined) {
                    isFilterByDateActive = flag;
                    isFilterByNumberActive = false;
                    isFilterByEskGroupActive = false;
                }
                return isFilterByDateActive;
            },

            filterByEskGroup: function (flag) {
                if (flag !== undefined) {
                    isFilterByEskGroupActive = flag;
                    isFilterByNumberActive = false;
                    isFilterByDateActive = false;
                }
                return isFilterByEskGroupActive;
            }
        }
    }]);
angular
    .module("violations")
    .factory("$misc", ["$log", "$http", "$errors", "$factory", function ($log, $http, $errors, $factory) {

        var eskGroups = [];
        var weekdays = [
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Понедельник", code: "monday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Вторник", code: "tuesday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Среда", code: "wednesday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Четверг", code: "thursday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Пятница", code: "friday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Суббота", code: "saturday" } }),
            $factory({ classes: ["Weekday"], base_class: "Weekday", init: { title: "Воскресение", code: "sunday" } })
        ];

        $log.info(weekdays);

        return {

            init: function (source) {
                if (source === undefined) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$misc -> init: Не задан параметр - источник данных");
                    return false;
                }

                if (source.eskGroups === undefined || source.eskGroups === null) {
                    $errors.add(ERROR_TYPE_DEFAULT, "$misc -> init: Данные о группах ЭСК не найдены");
                    return false;
                }

                var length = source.eskGroups.length;
                for (var i = 0; i < length; i++) {
                    var group = $factory({ classes: ["ESKGroup", "Model", "Backup", "States"], base_class: "ESKGroup" });
                    group._model_.fromJSON(source.eskGroups[i]);
                    group._backup_.setup();
                    eskGroups.push(group);
                }

                return true;
            },


            eskGroups: {

                getAll: function () {
                    return eskGroups;
                },

                getById: function (id) {
                    if (id === undefined) {
                        $errors.add(ERROR_TYPE_DEFAULT, "$misc -> eskGroups -> getById: Не задан параметр - идентификатор группы ЭСК");
                        return false;
                    }

                    var length = eskGroups.length;
                    for (var i = 0; i < length; i++) {
                        if (eskGroups[i].id.value === id)
                            return eskGroups[i];
                    }

                    return false;
                }
            },


            weekdays: {

                getAll: function () {
                    return weekdays;
                }
            }

        }
    }]);


angular.module("violations")
        .factory("$violations", ["$log", "$classes", "$factory", "$http", "$errors", "$session", "$tree", function ($log, $classes, $factory, $http, $errors, $session, $tree) {
            var violations = [];
            var attachments = [];
            var currentDivision = undefined;
            var newDivision = $factory({ classes: ["Division", "Model", "Backup", "States"], base_class: "Division" });
            newDivision._backup_.setup();
            var currentViolation = undefined;
            var newViolation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
            var newViolationAttachments = [];
            var currentViolationAttachments = [];
            var totalViolations = 0;
            var totalAttachments = 0;
            var thursday = 0;
            var isLoading = false;


            var isFilterEnabled = true;
            var isViolationIdSent = false;

            var pages = 0;
            var pagesLoaded = 1;
            var total = 0;
            var start = 0;

            var api = {
                init: function () {
                    if (window.initialData !== undefined) {

                        $log.log("startPeriod = ", moment.unix(window.initialData.startPeriod).format("DD.MM.YYYY HH:mm"));
                        $log.log("endPeriod = ", moment.unix(window.initialData.endPeriod).format("DD.MM.YYYY HH:mm"));
                        $log.log("today = ", moment.unix(window.initialData.today).format("DD.MM.YYYY HH:mm"));

                        if (window.initialData.thursday !== undefined && window.initialData.thursday !== null) {
                            thursday = window.initialData.thursday;
                        }

                        if (window.initialData.violations !== undefined) {

                            if (window.initialData.total !== undefined) {
                                total = window.initialData.total;
                                $log.log("total = ", total);
                                //pages = Math.ceil(window.initialData.total / itemsOnPage);
                            }

                            var length = window.initialData.violations.length;
                            for (var i = 0; i < length; i++) {
                                totalViolations++;
                                var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                violation._model_.fromJSON(window.initialData.violations[i].violation);
                                violation.isNew = violation.happened.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? true : false;
                                violation._backup_.setup();
                                var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                user._model_.fromJSON(window.initialData.violations[i].user);
                                violation.user = user;
                                //violation.attachments = [];

                                if (window.initialData.violations[i].attachments !== undefined && window.initialData.violations[i].attachments.length > 0) {
                                    var l = window.initialData.violations[i].attachments.length;
                                    for (var x = 0; x < l; x++) {
                                        totalAttachments++;
                                        var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                        attachment._model_.fromJSON(window.initialData.violations[i].attachments[x]);
                                        violation.newAttachments += attachment.added.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? 1 : 0;
                                        violation.attachments.push(attachment);
                                    }
                                }

                                violations.push(violation);
                            }
                            start = totalViolations;
                            //$log.log("violations = ", violations);
                        }


                        if (window.initialData.attachments !== undefined) {
                            var length = window.initialData.attachments.length;
                            for (var i = 0; i < length; i++) {
                                var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                attachment._model_.fromJSON(window.initialData.attachments[i]);
                                attachment._backup_.setup();
                                attachments.push(attachment);
                            }
                            //$log.log("attachments = ", attachments);
                        }
                    }
                },

                violations: {
                    pages: {
                        isMoreItems: function () {

                        },
                        getTotal: function () {
                            return total;
                        },
                        loadNextPage: function () {
                            var params = {
                                action: "getViolationsByDivisionId",
                                divisionId: currentDivision.id.value,
                                start: start
                            };
                            $http.post("/serverside/api.php", params)
                                .success(function (data) {
                                    if (data !== undefined && data.length > 0) {
                                        var length = data.length;
                                        for (var i = 0; i < length; i++) {
                                            var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                            violation._model_.fromJSON(data[i].violation);
                                            violation._backup_.setup();
                                            var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                            user._model_.fromJSON(data[i].user);
                                            violation.user = user;
                                            //violation.attachments = [];

                                            if (data[i].attachments !== undefined && data[i].attachments.length > 0) {
                                                var l = data[i].attachments.length;
                                                for (var x = 0; x < l; x++) {
                                                    var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                                    attachment._model_.fromJSON(data[i].attachments[x]);
                                                    violation.attachments.push(attachment);
                                                }
                                            }

                                                violations.push(violation);
                                        }




                                            var length = data.length;
                                            for (var i = 0; i < length; i++) {
                                                var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                                violation._model_.fromJSON(data[i]);
                                                violation._backup_.setup();
                                                violations.push(violation);
                                            }
                                    }
                                });
                        }
                    },
                    
                    startDate: 0,
                    endDate: 0,
                    loadMore: true,

                    loading: function (flag) {
                        if (flag !== undefined)
                            isLoading = flag;
                        return isLoading;
                    },

                    filterStartDate: function (date) {
                        if (date !== undefined)
                            startDate = date;
                        return startDate;
                    },

                    filterEndDate: function (date) {
                        if (date !== undefined)
                            endDate = date;
                        return endDate;
                    },

                    getControlDate: function () {
                        $log.log("friday = ", moment.unix(thursday).hours(23).minutes(59).seconds(59).format("DD.MM.YYY HH:mm"));
                        return moment.unix(thursday).hours(23).minutes(59).seconds(59).unix();
                    },

                    getNewByDivisionId: function (divisionId) {
                        var length = violations.length;
                        var result = {
                            violations: 0,
                            attachments: 0
                        };
                        for (var i = 0; i < length; i++) {
                            if (violations[i].divisionId.value === divisionId && violations[i].happened.value > this.getLastFriday()) {
                                result.violations++;
                                var al = violations[i].attachments.length;
                                for (var x = 0; x < al; x++) {
                                    if (violations[i].attachments[x].added.value > this.getLastFriday())
                                        result.attachments++;
                                }
                            }
                        }
                        return result;
                    },

                    setStart: function (value) {
                        start = value;
                    },

                    getTotalViolations: function () {
                        return totalViolations;
                    },
                    
                    getTotalAttachments: function () {
                        return totalAttachments;
                    },
                    
                    addAttachment: function () {
                        totalAttachments++;
                    },

                    getAll: function () {
                        return violations;
                    },

                    getCurrent: function () {
                        return currentViolation;
                    },
                    getNew: function () {
                        return newViolation;
                    },

                    getById: function (id, callback) {
                        if (id === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> loadById: Не задан параметр - идентификатор технологического нарушения");
                            return false;
                        }

                        var length = violations.length;
                        for (var i = 0; i < length; i++) {
                            if (violations[i].id.value === id) {
                                //$log.info("getting violation from cache");
                                currentViolation = violations[i];
                                return currentViolation;
                            }
                        }

                        var params = {
                            action: "getViolationById",
                            data: {
                                id: id
                            }
                        };
                        isLoading = true;
                        return $http.post("/serverside/api.php", params).then(
                            function success(response) {
                                isLoading = false;
                                //$log.info("promise success");
                                var violation = $factory({classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation"});
                                violation._model_.fromJSON(response.data.violation);
                                violation._backup_.setup();

                                var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                user._model_.fromJSON(response.data.user);
                                violation.user = user;

                                var length = response.data.attachments.length;
                                for (var i = 0; i < length; i++) {
                                    var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                    attachment._model_.fromJSON(response.data.attachments[i]);
                                    violation.attachments.push(attachment);
                                }

                                currentViolation = violation;
                                return currentViolation;
                            },
                            function error() {
                                isLoading = false;
                                return undefined;
                            }
                        );
                    },


                    searchById: function (id, callback) {
                        if (id === undefined) {
                            $errors.throw($errors.type.ERROR_TYPE_DEFAULT, "$violations -> violations -> searchById: Не задан параметр - идентификатор технологического нарушения");
                            return false;
                        }

                        var params = {
                            action: "searchById",
                            data: {
                                id: id
                            }
                        };
                        isLoading = true;
                        $http.post("/serverside/api.php", params).then(
                            function success (response) {
                                if (data !== undefined) {
                                    var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                    violation._model_.fromJSON(response.data.violation);
                                    violation._backup_.setup();

                                    var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                    user._model_.fromJSON(response.data.user);
                                    violation.user = user;

                                    var length = response.data.attachments.length;
                                    for (var i = 0; i < length; i++) {
                                        var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                        attachment._model_.fromJSON(response.data.attachments[i]);
                                        violation.attachments.push(attachment);
                                    }
                                }
                            },
                            function error () {
                                $errors.throw($errors.type.ERROR_TYPE_ENGINE, "$violations -> violations -> searchById: В процессе поиска возникла ошибка");
                                return false;
                            }
                        );

                    },

                    select: function (id, callback) {
                        if (id === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> select: Не залан параметр - идентификатор нарушения");
                            return false;
                        }

                        var length = violations.length;
                        for (var i = 0; i < length; i++) {
                            if (violations[i].id.value === id) {
                                if (violations[i]._states_.selected() === false) {
                                    violations[i]._states_.selected(true);
                                    currentViolation = violations[i];
                                } else {
                                    violations[i]._states_.selected(false);
                                    currentViolation = undefined;
                                }
                            } else
                                violations[i]._states_.selected(false);
                        }

                        if (callback !== undefined && typeof callback === "function")
                            callback(currentViolation);

                        return true;
                    },

                    getByDivisionId: function (divisionId, callback) {
                        //$log.log("startDate = ", this.startDate, ", endDate = ", this.endDate);
                        if (divisionId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> selectByDivisionId: Не задан парметр - идентификатор структурного подразделения");
                            return false;
                        }

                        /*
                        if (startDate === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> selectByDivisionId: Не задан парметр - начальная дата");
                            return false;
                        }

                        if (endDate === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> selectByDivisionId: Не задан парметр - конечная дата");
                            return false;
                        }
                        */


                        var params = {
                            action: "getViolationsByDivisionId",
                            data: {
                                divisionId: divisionId,
                                startDate: api.violations.filter.startDate,
                                endDate: api.violations.filter.endDate,
                                eskGroupId: api.violations.filter.eskGroupId,
                                start: start
                            }
                        };

                        if (this.startDate !== 0 || this.endDate !== 0)
                            start = 0;

                        if (start === 0) {
                            totalAttachments = 0;
                            totalViolations = 0;
                        }

                        isLoading = true;
                        $http.post("serverside/api.php", params)
                            .success(function (data) {
                                isLoading = false;
                                if (start === 0)
                                    violations = [];
                                if (data !== undefined && data.length > 0) {
                                    total = data[0].total;
                                    var length = data.length;
                                    for (var i = 0; i < length; i++) {
                                        start++;
                                        totalViolations++;
                                        var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                        violation._model_.fromJSON(data[i].violation);
                                        violation.isNew = violation.happened.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? true : false;
                                        violation._backup_.setup();
                                        var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                        user._model_.fromJSON(data[i].user);
                                        violation.user = user;
                                        //violation.attachments = [];

                                        if (data[i].attachments !== undefined && data[i].attachments.length > 0) {
                                            var l = data[i].attachments.length;
                                            for (var x = 0; x < l; x++) {
                                                totalAttachments++;
                                                var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                                attachment._model_.fromJSON(data[i].attachments[x]);
                                                violation.newAttachments += attachment.added.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? 1 : 0;
                                                violation.attachments.push(attachment);
                                            }
                                        }

                                        violations.push(violation);

                                        if (callback !== undefined && typeof callback === "function")
                                            callback();
                                    }




                                    //var length = data.length;
                                    //for (var i = 0; i < length; i++) {
                                    //    var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                    //    violation._model_.fromJSON(data[i]);
                                    //    violation._backup_.setup();
                                    //    violations.push(violation);
                                    //}
                                }
                            });
                    },

                    add: function (callback) {
                        var params = {
                            action: "addViolation",
                            data: {
                                id: newViolation.id.value,
                                userId: newViolation.userId.value,
                                divisionId: newViolation.divisionId.value,
                                eskGroupId: newViolation.eskGroupId.value,
                                eskObject: newViolation.eskObject.value,
                                happened: newViolation.happened.value,
                                ended: newViolation.ended.value,
                                description: newViolation.description.value
                            }
                        };

                        newViolation._states_.loading(true);
                        $http.post("/serverside/api.php", params)
                            .success(function (data) {
                                newViolation._states_.loading(false);
                                if (data !== undefined && data !== false) {
                                    totalViolations++;
                                    var violation = $factory({ classes: ["Violation", "Model", "Backup", "States"], base_class: "Violation" });
                                    violation._model_.fromJSON(data.violation);
                                    violation.isNew = violation.happened.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? true : false;
                                    violation._backup_.setup();
                                    var user = $factory({ classes: ["AppUser", "Model", "Backup", "States"], base_class: "AppUser" });
                                    user._model_.fromJSON(data.user);
                                    violation.user = user;

                                    violation.attachments = [];
                                    var length = data.attachments.length;
                                    for (var i = 0; i < length; i++) {
                                        totalAttachments++;
                                        var attachment = $factory({ classes: ["Attachment", "Model", "Backup", "States"], base_class: "Attachment" });
                                        attachment._model_.fromJSON(data.attachments[i]);
                                        violation.newAttachments += attachment.added.value > moment.unix(thursday).hours(23).minutes(59).seconds(59).unix() ? 1 : 0;
                                        violation.attachments.push(attachment);
                                    }

                                    //violations.push(violation);

                                    if (callback !== undefined && typeof callback === "function")
                                        callback(violation);

                                    return true;
                                }
                            });
                    },

                    edit: function (callback) {
                        var params = {
                            action: "editViolation",
                            data: {
                                id: currentViolation.id.value,
                                divisionId: currentViolation.divisionId.value,
                                userId: currentViolation.userId.value,
                                eskGroupId: currentViolation.eskGroupId.value,
                                eskObject: currentViolation.eskObject.value,
                                description: currentViolation.description.value,
                                happened: currentViolation.happened.value,
                                ended: currentViolation.ended.value,
                                isConfirmed: currentViolation.isConfirmed.value === true ? 1: 0
                            }
                        };
                        $http.post("/serverside/api.php", params)
                            .success(function (data) {
                                if (data !== undefined) {
                                    currentViolation._backup_.setup();
                                    if (callback !== undefined && typeof callback === "function")
                                        callback(currentViolation);
                                    return true;
                                }
                                return false;
                            });
                    },



                    cancel: function (violationId, url, departmentId, callback) {
                        if (violationId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> cancel: Не задан параметр - идентификатор технологического нарушения");
                            return false;
                        }

                        if (url === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> cancel: Не задан параметр - url");
                            return false;
                        }

                        if (departmentId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> cancel: Не задан параметр - идентификатор филиала организации");
                            return false;
                        }

                        var params = {
                            action: "cancelViolation",
                            data: {
                                serviceId: "violations",
                                violationId: newViolation.id.value,
                                departmentId: departmentId
                            }
                        };

                        newViolation._states_.loading(true);
                        $http.post(url, params)
                            .success(function (data) {
                                newViolation._states_.loading(false);
                                if (data !== undefined) {
                                    if (data === "true") {
                                        if (callback !== undefined && typeof callback === "function")
                                            callback();
                                        return true;
                                    }
                                }
                            });
                    },

                    addAttachmentToNew: function (attachment, callback) {
                        if (attachment === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> violations -> addAttachmentToNew: Не задан параметр - приложение");
                            return false;
                        }

                        newViolationAttachments.push(attachment);
                        if (callback !== undefined && typeof callback === "function")
                            callback(attachment);

                        return true;
                    },


                    filter: {
                        violationId: "",
                        startDate: 0,
                        endDate: 0,
                        eskGroupId: 0,

                        enabled: function (flag) {
                            if (flag !== undefined)
                                isFilterEnabled = flag;
                            return isFilterEnabled;
                        },

                        isIdSent: function (flag) {
                            if (flag !== undefined)
                                isViolationIdSent = flag;
                            return isViolationIdSent;
                        },

                        cancelStartDate: function (callback) {
                            this.startDate = 0;
                            if (callback !== undefined && typeof callback === "function")
                                callback();
                            return true;
                        },

                        cancelEndDate: function (callback) {
                            this.endDate = 0;
                            if (callback !== undefined && typeof callback === "function")
                                callback();
                            return true;
                        },

                        cancelEskGroup: function (callback) {
                            this.eskGroupId = 0;
                            if (callback !== undefined && typeof callback === "function")
                                callback();
                            return true;
                        }
                    }
                },


                attachments: {
                    getAll: function () {
                        return attachments;
                    },
                    
                    getNew: function () {
                        return newViolationAttachments;
                    },

                    getCurrentViolationAttachments: function () {
                        return currentViolationAttachments;
                    },

                    getByViolationId: function (violationId, callback) {
                        if (violationId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> attachments -> getByViolationId: Не задан параметр - идентификатор технологического нарушения");
                            return false;
                        }

                        var length = attachments.length;
                        currentViolationAttachments = [];
                        for (var i = 0; i < length; i++) {
                            if (attachments[i].violationId.value === violationId) {
                                currentViolationAttachments.push(attachments[i]);
                            }
                        }
                    },

                    add: function (attachment, callback) {
                        if (attachment === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> attachments: Не задан параметр - добавляемое вложение");
                            return false;
                        }

                        attachments.push(attachment);
                        if (callback !== undefined && typeof callback === "function")
                            callback(attachment);
                        return true;
                    },


                    /**
                     * Удаляет вложение, загруженное в режиме добавления или редактирования ТН
                     * @param attachmentId {number} - Идеентификатор вложения
                     * @param departmentId {number} - Идентификатор филиали организации
                     * @param url {string} - Url скрипта
                     * @param callback {function} - callback-функция
                     * @returns {boolean} - true в случае успеха, false в противном случае
                     */
                    delete: function (attachmentId, departmentId, url, callback) {
                        if (attachmentId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> attachments -> delete: Не задан параметр - идентификатор вложения");
                            return false;
                        }

                        if (departmentId === undefined) {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> attachments -> delete: Не задан параметр - идентификатор филиала организации");
                            return false;
                        }

                        if (url === undefined || url === "") {
                            $errors.add(ERROR_TYPE_DEFAULT, "$violations -> attachments -> delete: Не задан параметр - url скрипта удаления документа");
                            return false;
                        }

                        var params = {
                            serviceId: "violations",
                            attachmentId: attachmentId,
                            departmentId: departmentId
                        };
                        $http.post(url, params)
                            .success(function (data) {
                                if (data !== undefined) {
                                    if (data === "true") {
                                        if (callback !== undefined && typeof callback === "function")
                                            callback();
                                        return true;
                                    } else
                                        return false;
                                }
                            })
                            .error(function () {
                                return false;
                            });
                    }
                }
            };

            return api;
        }]);
angular
    .module("violations")
    .directive("structure", ["$log", "$templateCache", "$errors", "$structure", function ($log, $templateCache, $errors, $structure) {

        var template =
            "<div class='container nested'>" +
            "<div class=\"tree-item\" ng-class='{ \"with-children\": node.childrenCount > 0, \"expanded\": node.isExpanded === true && node.childrenCount > 0, \"active\": node.isSelected === true }' ng-repeat=\"node in node.children | toArray | orderBy: \'order\' track by $index\">" +
            "<div class='tree-item-content' ng-click='expand(node)'>" +
            "<div class='item-label' ng-class='{ \"active\": node.isSelected === true }' ng-click='select(node, $event)'>" +
            "<span>{{ node.display }}</span>" +
            "</div>" +
            "<div class='item-controls'>" +
            "<span class='expand fa fa-chevron-down' ng-click='expand(node)' ng-show='node.childrenCount > 0 && node.isExpanded === false'></span>" +
            "<span class='collapse fa fa-chevron-up' ng-if='node.isExpanded === true && node.childrenCount > 0' ng-click='collapse(node)'></span>" +
            "</div>" +
                "<div class='item-notifications' ng-show='node.notifications.items.length === 0'>" +
                    "<div class='notification {{ notification.class }}' ng-repeat='notification in node.notifications.items track by $index' ng-show='notification.isVisible === true'>" +
                        "<span class='fa {{ notification.icon }} notification.class' ng-show='notification.icon !== \"\"'></span>" +
                        "<span class='value'>{{ notification.value }}</span>" +
                    "</div>" +
                    "<div class='notification violation-notification' ng-show='node.data.violationsTotal > 0'>" +
                        "<span class='fa fa-bolt'></span>" +
                        "<span class='value'>{{ node.data.violationsTotal }}</span>" +
                    "</div>" +
                    "<div class='notification attachment-notification' ng-show='node.data.attachmentsTotal > 0'>" +
                        "<span class='fa fa-file'></span>" +
                        "<span class='value'>{{ node.data.attachmentsTotal }}</span>" +
                    "</div>" +
                "</div>" +
            "</div>" +
            "<div ng-show='node.isExpanded === true' ng-include=\"\'structure'\"></div>" +
            "</div>" +
            "</div>";

        return {
            restrict: "E",
            scope: {
                class: "@"
            },
            template:
                "<div class='{{ \"krypton-ui-tree \" + class }}'>" +
                    "<div class='container root'>" +
                        "<div class='tree-item' ng-class='{ \"with-children\": node.childrenCount > 0, \"expanded\": node.isExpanded === true, \"active\": node.isSelected === true }' ng-repeat='node in initial | orderBy:\"order\" track by $index' ng-init='this.nv = this.nv + node.data.violationsAdded'>" +
                            "<div class='tree-item-content' ng-click='expand(node)'>" +
                                "<div class='item-label' ng-class='{ active: node.isSelected === true }' ng-click='select(node, $event)'>" +
                                    "<span>{{ node.display }}</span>" +
                                "</div>" +
                                "<div class='item-controls'>" +
                                    "<span class='expand fa fa-chevron-down' ng-click='expand(node)' ng-show='node.children.length > 0 && node.isExpanded === false'></span>" +
                                    "<span class='collapse fa fa-chevron-up' ng-if='node.isExpanded === true' ng-click='collapse(node)'></span>" +
                                "</div>" +
                                "<div class='item-notifications' ng-show='node.notifications.items.length === 0'>" +
                                    "<div class='notification {{ notification.class }}' ng-repeat='notification in node.notifications.items track by $index' ng-show='notification.isVisible === true'>" +
                                        "<span class='fa {{ notification.icon }}' ng-show='notification.icon !== \"\"'></span>" +
                                        "<span class='value'>{{ notification.value }}</span>" +
                                    "</div>" +
                                    "<div class='notification violation-notification' ng-show='node.data.violationsTotal > 0'>" +
                                        "<span class='fa fa-bolt'></span>" +
                                        "<span class='value'>{{ node.data.violationsTotal }}</span>" +
                                    "</div>" +
                                    "<div class='notification attachment-notification' ng-show='node.data.attachmentsTotal > 0'>" +
                                        "<span class='fa fa-file'></span>" +
                                        "<span class='value'>{{ node.data.attachmentsTotal }}</span>" +
                                    "</div>" +
                                "</div>" +
                            "</div>" +
                            "<div ng-init='this.parent = this' ng-include=\"\'structure'\" ng-show='node.isExpanded === true'></div>" +
                        "</div>" +
                    "</div>" +
                "</div>",
            link: function (scope, element, attrs) {

                if (attrs.id === undefined || attrs.id === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - идентификатор дерева");
                    return false;
                }

                if (attrs.rootKey === undefined || attrs.rootKey === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - значение коюча корневого элемента дерева");
                    return false;
                }

                if (attrs.rootKeyDataType === undefined || attrs.rootKeyDataType === "") {
                    $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Не задан параметр - тип данных коюча корневого элемента дерева");
                    return false;
                }


                var initial = scope.initial = {};
                var stack = scope.stack = {};

                var root = 0;
                switch (attrs.rootKeyDataType) {
                    case "DATA_TYPE_INTEGER":
                        if (isNaN(parseInt(attrs.rootKey))) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Значение ключа корневого элемента не соответствует типу данных коючевого элемента");
                            return false;
                        }
                        root = parseInt(attrs.rootKey);
                        break;
                    case "DATA_TYPE_FLOAT":
                        if (isNaN(parseFloat(attrs.rootKey))) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Значение ключа корневого элемента не соответствует типу данных коючевого элемента");
                            return false;
                        }
                        root = parseFloat(attrs.rootKey);
                        break;
                    case "DATA_TYPE_STRING":
                        root = attrs.rootKey.toString();
                        break;
                    default:
                        $errors.add(ERROR_TYPE_ENGINE, "structure directive -> Неверно задан тип данных корневого элемента");
                        return false;
                        break;
                }


                $log.log(attrs);


                $templateCache.put("structure", template);
                var tree = $structure.getById(attrs.id);
                if (tree !== false) {
                    scope.initial = tree.initial;
                    scope.stack = tree.stack;
                } else {
                    $structure.register({
                        id: attrs.id,
                        rootKey: root,
                        expandOnSelect: attrs.expandOnSelect !== undefined ? true : false,
                        collapseOnDeselect: attrs.collapseOnDeselect !== undefined ? true : false
                    });
                }



                scope.select = function (item, event) {
                    event.stopPropagation();
                    if (item !== undefined) {
                        if (!$structure.selectItem(attrs.id, item.key)) {
                            $errors.add(ERROR_TYPE_ENGINE, "structure directive -> '" + attrs.id + "' select: Не удалось выбрать элемент с идентификатором " + item.key);
                            return false;
                        }
                        return true;
                    }
                };



                scope.expand = function (item) {
                    if (item !== undefined) {
                        $log.log(item);
                        if (item.isExpanded == false) {
                            if (!$structure.expandItem(attrs.id, item.key)) {
                                $errors.add(ERROR_TYPE_ENGINE, "structure directive -> expand: не удвлось развернуть элемент с идентификатором " + item.key);
                                return false;
                            }
                        } else {
                            if (!$structure.collapseItem(attrs.id, item.key)) {
                                $errors.add(ERROR_TYPE_ENGINE, "structure directive -> expand: Не удалось свернуть элемент с идентификатором " + item.key);
                                return false;
                            }
                        }
                        return true;
                    }
                };

            }
        }
    }]);
angular
    .module("application", ["ngRoute", "ngCookies", "ngAnimate", "violations", "homunculus", "homunculus.ui"])
    .config(["$routeProvider", "$locationProvider", "$httpProvider", function ($routeProvider, $locationProvider, $httpProvider) {

        $httpProvider.defaults.useXDomain = true;
        delete $httpProvider.defaults.headers.common['X-Requested-With'];
        $httpProvider.defaults.headers.common = {};
        $httpProvider.defaults.headers.post = {};
        $httpProvider.defaults.headers.put = {};
        $httpProvider.defaults.headers.patch = {};

        //$locationProvider.html5Mode(true);
        $routeProvider
            .when("/", {
                templateUrl: "clientside/modules/violations/templates/violations.html",
                controller: "ViolationsController"
            })
            .when("/new", {
                templateUrl: "clientside/modules/violations/templates/new-violation.html",
                controller: "NewViolationController"
            })
            .when("/violations/:violationId", {
                templateUrl: "clientside/modules/violations/templates/violation.html",
                controller: "ViolationController",
                resolve: {
                    violation: ["$log", "$http", "$route", "$violations", function ($log, $http, $route, $violations) {
                        $violations.violations.getById(parseInt($route.current.params.violationId));
                    }]
                }
            })
            .when("/divisions/", {
                templateUrl: "clientside/modules/violations/templates/divisions/divisions.html",
                controller: "DivisionsController",
                resolve: {
                    access: ["$location", "$session", function ($location, $session) {
                        if ($session.getCurrentUser().isAdministrator.value === false)
                            $location.url("/");
                    }]
                }
            })
            .when("/users/", {
                templateUrl: "clientside/modules/violations/templates/users/users.html",
                controller: "UsersController",
                resolve: {
                    access: ["$location", "$session", function ($location, $session) {
                        if ($session.getCurrentUser().isAdministrator.value === false)
                            $location.url("/");
                    }]
                }
            })
            .when("/user/:userId", {
                templateUrl: "clientside/modules/violations/templates/users/user.html",
                controller: "UserController",
                resolve: {
                    access: ["$location", "$session", function ($location, $session) {
                        if ($session.getCurrentUser().isAdministrator.value === false)
                            $location.url("/");
                    }],
                    user: ["$log", "$http", "$route", "$users", "$session", function ($log, $http, $route, $users, $session) {
                        if ($session.getCurrentUser().isAdministrator.value === true)
                            $users.users.getById(parseInt($route.current.params.userId));
                    }]
                }
            })
            .when("/new-user", {
                templateUrl: "clientside/modules/violations/templates/users/new-user.html",
                controller: "NewUserController",
                resolve: {
                    access: ["$location", "$session", function ($location, $session) {
                        if ($session.getCurrentUser().isAdministrator.value === false)
                            $location.url("/");
                    }]
                }
            })
            .when("/help/", {
                templateUrl: "clientside/modules/violations/templates/help/help.html",
                controller: "HelpController"
            })
            .otherwise({
                redirectTo: "/"
            });
    }])
    .run(["$log", "$violations", "$navigation", function ($log, $violations, $navigation) {
        moment.locale("ru");
        $violations.violations.getNew().happened.value = new moment().hours(0).minutes(0).seconds(0).unix();
        $violations.violations.getNew().ended.value = $violations.violations.getNew().happened.value;
        //$log.log(window.initialData);
    }]);
